using System;
using System.IO;
using System.Linq;
using System.Collections.Generic;
using System.Security.Cryptography;

using Flazzy;
using Flazzy.IO;
using Flazzy.ABC;
using Flazzy.Tags;
using Flazzy.Records;
using Flazzy.ABC.AVM2;
using Flazzy.ABC.AVM2.Instructions;

namespace Interceptor.Habbo
{
    [Flags]
    public enum Sanitizers
    {
        None = 0,
        Deobfuscate = 1,
        RegisterRename = 2,
        IdentifierRename = 4
    }

    public class HGame : ShockwaveFlash
    {
        #region Modified XML Files
        private const string BADGE_DETAILS_XML =
            "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4NCjxsYXlvdXQgbmFtZT0iYmFkZ2VfZGV0YWlscyIgd2lkdGg9IjIwIiBoZWlnaHQ9IjIwIiB2ZXJzaW9uPSIwLjAiPg0KICA8d2luZG93Pg0KICAgIDxib3JkZXIgeD0iODciIHk9IjUzIiB3aWR0aD0iMjYzIiBoZWlnaHQ9Ijk5IiBwYXJhbXM9IjAiIHN0eWxlPSIwIiBuYW1lPSJ0ZXN0Ij4NCiAgICAgIDxjaGlsZHJlbj4NCiAgICAgICAgPHRleHQgeD0iOCIgeT0iNiIgd2lkdGg9IjI1MCIgaGVpZ2h0PSIyOCIgcGFyYW1zPSIxNiIgc3R5bGU9IjAiIG5hbWU9Im5hbWUiIGNhcHRpb249IiI+DQogICAgICAgICAgPHZhcmlhYmxlcz4NCiAgICAgICAgICAgIDx2YXIga2V5PSJmb250X2ZhY2UiIHZhbHVlPSJWb2x0ZXIgQm9sZCIgdHlwZT0iU3RyaW5nIi8+DQogICAgICAgICAgICA8dmFyIGtleT0iZm9udF9zaXplIiB2YWx1ZT0iOSIgdHlwZT0idWludCIvPg0KICAgICAgICAgICAgPHZhciBrZXk9InRleHRfY29sb3IiIHZhbHVlPSIweDAiIHR5cGU9ImhleCIvPg0KICAgICAgICAgICAgPHZhciBrZXk9ImVtYmVkX2ZvbnRzIiB2YWx1ZT0idHJ1ZSIgdHlwZT0iQm9vbGVhbiIvPg0KICAgICAgICAgICAgPHZhciBrZXk9IndvcmRfd3JhcCIgdmFsdWU9InRydWUiIHR5cGU9IkJvb2xlYW4iLz4NCiAgICAgICAgICA8L3ZhcmlhYmxlcz4NCiAgICAgICAgPC90ZXh0Pg0KICAgICAgICA8dGV4dCB4PSI4IiB5PSIzMyIgd2lkdGg9IjI1MCIgaGVpZ2h0PSI2MCIgcGFyYW1zPSIxNiIgc3R5bGU9IjAiIG5hbWU9ImRlc2NyaXB0aW9uIiBjYXB0aW9uPSIiIGNsaXBwaW5nPSJmYWxzZSI+DQogICAgICAgICAgPHZhcmlhYmxlcz4NCiAgICAgICAgICAgIDx2YXIga2V5PSJmb250X2ZhY2UiIHZhbHVlPSJWb2x0ZXIiIHR5cGU9IlN0cmluZyIvPg0KICAgICAgICAgICAgPHZhciBrZXk9ImZvbnRfc2l6ZSIgdmFsdWU9IjkiIHR5cGU9InVpbnQiLz4NCiAgICAgICAgICAgIDx2YXIga2V5PSJ0ZXh0X2NvbG9yIiB2YWx1ZT0iMHgwIiB0eXBlPSJoZXgiLz4NCiAgICAgICAgICAgIDx2YXIga2V5PSJlbWJlZF9mb250cyIgdmFsdWU9InRydWUiIHR5cGU9IkJvb2xlYW4iLz4NCiAgICAgICAgICAgIDx2YXIga2V5PSJ3b3JkX3dyYXAiIHZhbHVlPSJ0cnVlIiB0eXBlPSJCb29sZWFuIi8+DQogICAgICAgICAgPC92YXJpYWJsZXM+DQogICAgICAgIDwvdGV4dD4NCiAgICAgIDwvY2hpbGRyZW4+DQogICAgPC9ib3JkZXI+DQogIDwvd2luZG93Pg0KPC9sYXlvdXQ+";

        private const string FURNI_VIEW_XML =
            "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4NCjxsYXlvdXQgbmFtZT0iZnVybmlfdmlldyIgd2lkdGg9IjQyOSIgaGVpZ2h0PSI0OTciIHZlcnNpb249IjAuMSIgdWlkPSI3MDkzRkIyNS1CQTkwLUY0QTAtODgzMC0yQzBCN0EwNkFBRjYiPg0KICA8d2luZG93Pg0KICAgIDxpdGVtbGlzdF92ZXJ0aWNhbCB4PSIwIiB5PSIwIiB3aWR0aD0iNDI5IiBoZWlnaHQ9IjQ5NyIgcGFyYW1zPSIxNiIgc3R5bGU9IjAiPg0KICAgICAgPGNoaWxkcmVuPg0KICAgICAgICA8Ym9yZGVyIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTAiIGhlaWdodD0iMzkwIiBwYXJhbXM9IjE2IiBzdHlsZT0iMSIgbmFtZT0iaW5mb19ib3JkZXIiPg0KICAgICAgICAgIDxjaGlsZHJlbj4NCiAgICAgICAgICAgIDxjbG9zZWJ1dHRvbiB4PSIxNjgiIHk9IjYiIHdpZHRoPSIxOCIgaGVpZ2h0PSIxNiIgcGFyYW1zPSIxNyIgc3R5bGU9IjEiIGJhY2tncm91bmQ9InRydWUiIHRyZXNob2xkPSIwIiB0YWdzPSJjbG9zZSIvPg0KICAgICAgICAgICAgPGl0ZW1saXN0X3ZlcnRpY2FsIHg9IjEwIiB5PSIxMCIgd2lkdGg9IjE3MCIgaGVpZ2h0PSIzODkiIHBhcmFtcz0iMTYiIHN0eWxlPSIwIiBuYW1lPSJpbmZvc3RhbmRfZWxlbWVudF9saXN0Ij4NCiAgICAgICAgICAgICAgPGNoaWxkcmVuPg0KICAgICAgICAgICAgICAgIDx0ZXh0IHg9IjAiIHk9IjAiIHdpZHRoPSIxNTkiIGhlaWdodD0iMTIiIHBhcmFtcz0iMTQ0IiBzdHlsZT0iMCIgbmFtZT0ibmFtZV90ZXh0IiBjYXB0aW9uPSJGdXJuaSUyMG5hbWUiPg0KICAgICAgICAgICAgICAgICAgPHZhcmlhYmxlcz4NCiAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9ImZvbnRfZmFjZSIgdmFsdWU9IlZvbHRlciBCb2xkIiB0eXBlPSJTdHJpbmciLz4NCiAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9InRleHRfY29sb3IiIHZhbHVlPSIweGZmZmZmZiIgdHlwZT0iaGV4Ii8+DQogICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJtb3VzZV93aGVlbF9lbmFibGVkIiB2YWx1ZT0iZmFsc2UiIHR5cGU9IkJvb2xlYW4iLz4NCiAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9InNoYXJwbmVzcyIgdmFsdWU9IjAiIHR5cGU9Ik51bWJlciIvPg0KICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0idGhpY2tuZXNzIiB2YWx1ZT0iMCIgdHlwZT0iTnVtYmVyIi8+DQogICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJ3b3JkX3dyYXAiIHZhbHVlPSJ0cnVlIiB0eXBlPSJCb29sZWFuIi8+DQogICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJrZXJuaW5nIiB2YWx1ZT0iZmFsc2UiIHR5cGU9IkJvb2xlYW4iLz4NCiAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9InNwYWNpbmciIHZhbHVlPSIwIiB0eXBlPSJOdW1iZXIiLz4NCiAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9ImxlYWRpbmciIHZhbHVlPSIwIiB0eXBlPSJOdW1iZXIiLz4NCiAgICAgICAgICAgICAgICAgIDwvdmFyaWFibGVzPg0KICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICA8Y29udGFpbmVyIHg9IjAiIHk9IjE3IiB3aWR0aD0iMTcwIiBoZWlnaHQ9IjEiIHBhcmFtcz0iMTYiIHN0eWxlPSIwIiBuYW1lPSJpbWFnZXNfc3BhY2VyIiBjb2xvcj0iMHhmZmZmMzMzMzMzIiBiYWNrZ3JvdW5kPSJ0cnVlIi8+DQogICAgICAgICAgICAgICAgPGNvbnRhaW5lciB4PSIwIiB5PSIyMyIgd2lkdGg9IjE3MCIgaGVpZ2h0PSIxMzAiIHBhcmFtcz0iMTYiIHN0eWxlPSIwIiBuYW1lPSJpbWFnZV9jb250YWluZXIiIGhlaWdodF9taW49IjQ1Ij4NCiAgICAgICAgICAgICAgICAgIDxjaGlsZHJlbj4NCiAgICAgICAgICAgICAgICAgICAgPGNvbnRhaW5lciB4PSIwIiB5PSIwIiB3aWR0aD0iMTcwIiBoZWlnaHQ9IjEzMCIgcGFyYW1zPSIyMDk2IiBzdHlsZT0iMCIgbmFtZT0idW5pcXVlX2l0ZW1fYmFja2dyb3VuZF9jb250YWluZXIiIHZpc2libGU9ImZhbHNlIiBoZWlnaHRfbWluPSI0NSI+DQogICAgICAgICAgICAgICAgICAgICAgPGNoaWxkcmVuPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRpY19iaXRtYXAgeD0iOCIgeT0iLTEiIHdpZHRoPSI1IiBoZWlnaHQ9IjkiIHBhcmFtcz0iMCIgc3R5bGU9IjAiIG5hbWU9InVuaXF1ZV9pdGVtX2JhY2tncm91bmRfYm90dG9tIj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHZhcmlhYmxlcz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0iYXNzZXRfdXJpIiB2YWx1ZT0idW5pcXVlX2l0ZW1fbGFyZ2VfaXJvbiIgdHlwZT0iU3RyaW5nIi8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9InN0cmV0Y2hlZF94IiB2YWx1ZT0iZmFsc2UiIHR5cGU9IkJvb2xlYW4iLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0ic3RyZXRjaGVkX3kiIHZhbHVlPSJmYWxzZSIgdHlwZT0iQm9vbGVhbiIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8L3ZhcmlhYmxlcz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvc3RhdGljX2JpdG1hcD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0aWNfYml0bWFwIHg9IjE1NSIgeT0iLTEiIHdpZHRoPSI1IiBoZWlnaHQ9IjkiIHBhcmFtcz0iMCIgc3R5bGU9IjAiIG5hbWU9InVuaXF1ZV9pdGVtX2JhY2tncm91bmRfYm90dG9tIj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHZhcmlhYmxlcz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0iYXNzZXRfdXJpIiB2YWx1ZT0idW5pcXVlX2l0ZW1fbGFyZ2VfaXJvbiIgdHlwZT0iU3RyaW5nIi8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9InN0cmV0Y2hlZF94IiB2YWx1ZT0iZmFsc2UiIHR5cGU9IkJvb2xlYW4iLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0ic3RyZXRjaGVkX3kiIHZhbHVlPSJmYWxzZSIgdHlwZT0iQm9vbGVhbiIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8L3ZhcmlhYmxlcz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvc3RhdGljX2JpdG1hcD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0aWNfYml0bWFwIHg9IjAiIHk9IjUiIHdpZHRoPSIxNzAiIGhlaWdodD0iMTIwIiBwYXJhbXM9IjIwNjQiIHN0eWxlPSIwIiBuYW1lPSJ1bmlxdWVfaXRlbV9iYWNrZ3JvdW5kX21pZCI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDx2YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9ImFzc2V0X3VyaSIgdmFsdWU9InVuaXF1ZV9pdGVtX2xhcmdlX2dsYXNzX21pZCIgdHlwZT0iU3RyaW5nIi8+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDwvdmFyaWFibGVzPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9zdGF0aWNfYml0bWFwPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRpY19iaXRtYXAgeD0iMCIgeT0iMCIgd2lkdGg9IjE3MCIgaGVpZ2h0PSI1IiBwYXJhbXM9IjE2IiBzdHlsZT0iMCIgbmFtZT0idW5pcXVlX2l0ZW1fYmFja2dyb3VuZF90b3AiPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8dmFyaWFibGVzPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJhc3NldF91cmkiIHZhbHVlPSJ1bmlxdWVfaXRlbV9sYXJnZV9nbGFzc190b3AiIHR5cGU9IlN0cmluZyIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8L3ZhcmlhYmxlcz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvc3RhdGljX2JpdG1hcD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0aWNfYml0bWFwIHg9IjAiIHk9IjEyNSIgd2lkdGg9IjE3MCIgaGVpZ2h0PSI1IiBwYXJhbXM9IjEwNDAiIHN0eWxlPSIwIiBuYW1lPSJ1bmlxdWVfaXRlbV9iYWNrZ3JvdW5kX2JvdHRvbSI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDx2YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9ImFzc2V0X3VyaSIgdmFsdWU9InVuaXF1ZV9pdGVtX2xhcmdlX2dsYXNzX2JvdHRvbSIgdHlwZT0iU3RyaW5nIi8+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDwvdmFyaWFibGVzPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9zdGF0aWNfYml0bWFwPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRpY19iaXRtYXAgeD0iOCIgeT0iMTIzIiB3aWR0aD0iNSIgaGVpZ2h0PSI5IiBwYXJhbXM9IjEwMjQiIHN0eWxlPSIwIiBuYW1lPSJ1bmlxdWVfaXRlbV9iYWNrZ3JvdW5kX2JvdHRvbSI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDx2YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9ImFzc2V0X3VyaSIgdmFsdWU9InVuaXF1ZV9pdGVtX2xhcmdlX2lyb24iIHR5cGU9IlN0cmluZyIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJzdHJldGNoZWRfeCIgdmFsdWU9ImZhbHNlIiB0eXBlPSJCb29sZWFuIi8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9InN0cmV0Y2hlZF95IiB2YWx1ZT0iZmFsc2UiIHR5cGU9IkJvb2xlYW4iLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC92YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgICAgICAgICA8L3N0YXRpY19iaXRtYXA+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGljX2JpdG1hcCB4PSIxNTUiIHk9IjEyMyIgd2lkdGg9IjUiIGhlaWdodD0iOSIgcGFyYW1zPSIxMDI0IiBzdHlsZT0iMCIgbmFtZT0idW5pcXVlX2l0ZW1fYmFja2dyb3VuZF9ib3R0b20iPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8dmFyaWFibGVzPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJhc3NldF91cmkiIHZhbHVlPSJ1bmlxdWVfaXRlbV9sYXJnZV9pcm9uIiB0eXBlPSJTdHJpbmciLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0ic3RyZXRjaGVkX3giIHZhbHVlPSJmYWxzZSIgdHlwZT0iQm9vbGVhbiIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJzdHJldGNoZWRfeSIgdmFsdWU9ImZhbHNlIiB0eXBlPSJCb29sZWFuIi8+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDwvdmFyaWFibGVzPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9zdGF0aWNfYml0bWFwPg0KICAgICAgICAgICAgICAgICAgICAgIDwvY2hpbGRyZW4+DQogICAgICAgICAgICAgICAgICAgIDwvY29udGFpbmVyPg0KICAgICAgICAgICAgICAgICAgICA8Yml0bWFwIHg9IjUiIHk9IjUiIHdpZHRoPSIxNDAiIGhlaWdodD0iMTIwIiBwYXJhbXM9IjgzODg2MjQiIHN0eWxlPSIwIiBuYW1lPSJpbWFnZSIgaGVpZ2h0X21pbj0iNDUiPg0KICAgICAgICAgICAgICAgICAgICAgIDx2YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0icGl2b3RfcG9pbnQiIHZhbHVlPSJjZW50ZXIiIHR5cGU9IlN0cmluZyIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9InN0cmV0Y2hlZF94IiB2YWx1ZT0iZmFsc2UiIHR5cGU9IkJvb2xlYW4iLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJzdHJldGNoZWRfeSIgdmFsdWU9ImZhbHNlIiB0eXBlPSJCb29sZWFuIi8+DQogICAgICAgICAgICAgICAgICAgICAgPC92YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgICAgIDwvYml0bWFwPg0KICAgICAgICAgICAgICAgICAgICA8Y29udGFpbmVyIHg9IjAiIHk9IjAiIHdpZHRoPSIxNzAiIGhlaWdodD0iMTMwIiBwYXJhbXM9IjIwOTYiIHN0eWxlPSIwIiBuYW1lPSJ1bmlxdWVfaXRlbV9vdmVybGF5X2NvbnRhaW5lciIgdmlzaWJsZT0iZmFsc2UiIGhlaWdodF9taW49IjQ1Ij4NCiAgICAgICAgICAgICAgICAgICAgICA8Y2hpbGRyZW4+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGljX2JpdG1hcCB4PSIwIiB5PSI1IiB3aWR0aD0iMTcwIiBoZWlnaHQ9IjEyMCIgcGFyYW1zPSIyMDY0IiBzdHlsZT0iMCI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDx2YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9ImFzc2V0X3VyaSIgdmFsdWU9InVuaXF1ZV9pdGVtX2xhcmdlX2dsYXNzX3NoaW5lIiB0eXBlPSJTdHJpbmciLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC92YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgICAgICAgICA8L3N0YXRpY19iaXRtYXA+DQogICAgICAgICAgICAgICAgICAgICAgICA8d2lkZ2V0IHg9IjEyOCIgeT0iNiIgd2lkdGg9IjQwIiBoZWlnaHQ9IjQwIiBwYXJhbXM9IjE2IiBzdHlsZT0iMCIgbmFtZT0idW5pcXVlX2l0ZW1fcGxhcXVlX3dpZGdldCI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDx2YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9IndpZGdldF90eXBlIiB2YWx1ZT0ibGltaXRlZF9pdGVtX292ZXJsYXlfcHJldmlldyIgdHlwZT0iU3RyaW5nIi8+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDwvdmFyaWFibGVzPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC93aWRnZXQ+DQogICAgICAgICAgICAgICAgICAgICAgPC9jaGlsZHJlbj4NCiAgICAgICAgICAgICAgICAgICAgPC9jb250YWluZXI+DQogICAgICAgICAgICAgICAgICAgIDxjb250YWluZXIgeD0iMCIgeT0iMCIgd2lkdGg9IjE3MCIgaGVpZ2h0PSIxMzAiIHBhcmFtcz0iMjA5NiIgc3R5bGU9IjAiIG5hbWU9InJhcml0eV9pdGVtX292ZXJsYXlfY29udGFpbmVyIiB2aXNpYmxlPSJmYWxzZSI+DQogICAgICAgICAgICAgICAgICAgICAgPGNoaWxkcmVuPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHdpZGdldCB4PSIxMjgiIHk9IjYiIHdpZHRoPSI0MCIgaGVpZ2h0PSI0MCIgcGFyYW1zPSIxNiIgc3R5bGU9IjAiIG5hbWU9InJhcml0eV9pdGVtX292ZXJsYXlfd2lkZ2V0Ij4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHZhcmlhYmxlcz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0id2lkZ2V0X3R5cGUiIHZhbHVlPSJyYXJpdHlfaXRlbV9vdmVybGF5X3ByZXZpZXciIHR5cGU9IlN0cmluZyIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8L3ZhcmlhYmxlcz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvd2lkZ2V0Pg0KICAgICAgICAgICAgICAgICAgICAgIDwvY2hpbGRyZW4+DQogICAgICAgICAgICAgICAgICAgIDwvY29udGFpbmVyPg0KICAgICAgICAgICAgICAgICAgPC9jaGlsZHJlbj4NCiAgICAgICAgICAgICAgICA8L2NvbnRhaW5lcj4NCiAgICAgICAgICAgICAgICA8Y29udGFpbmVyIHg9IjAiIHk9IjE1OCIgd2lkdGg9IjE3MCIgaGVpZ2h0PSIxIiBwYXJhbXM9IjE2IiBzdHlsZT0iMCIgbmFtZT0iZGVzY3JpcHRpb25fc3BhY2VyIiBjb2xvcj0iMHhmZmZmMzMzMzMzIiBiYWNrZ3JvdW5kPSJ0cnVlIi8+DQogICAgICAgICAgICAgICAgPHRleHQgeD0iMCIgeT0iMTY0IiB3aWR0aD0iMTcwIiBoZWlnaHQ9IjQwIiBwYXJhbXM9IjE2IiBzdHlsZT0iMCIgbmFtZT0iZGVzY3JpcHRpb25fdGV4dCIgY2FwdGlvbj0iRnVybmklMjBkZXNjcmlwdGlvbiI+DQogICAgICAgICAgICAgICAgICA8dmFyaWFibGVzPg0KICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0idGV4dF9jb2xvciIgdmFsdWU9IjB4ZmZmZmZmIiB0eXBlPSJoZXgiLz4NCiAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9Im1vdXNlX3doZWVsX2VuYWJsZWQiIHZhbHVlPSJmYWxzZSIgdHlwZT0iQm9vbGVhbiIvPg0KICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0ic2hhcnBuZXNzIiB2YWx1ZT0iMCIgdHlwZT0iTnVtYmVyIi8+DQogICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJ0aGlja25lc3MiIHZhbHVlPSIwIiB0eXBlPSJOdW1iZXIiLz4NCiAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9IndvcmRfd3JhcCIgdmFsdWU9InRydWUiIHR5cGU9IkJvb2xlYW4iLz4NCiAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9Imtlcm5pbmciIHZhbHVlPSJmYWxzZSIgdHlwZT0iQm9vbGVhbiIvPg0KICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0ic3BhY2luZyIgdmFsdWU9IjAiIHR5cGU9Ik51bWJlciIvPg0KICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0ibGVhZGluZyIgdmFsdWU9IjAiIHR5cGU9Ik51bWJlciIvPg0KICAgICAgICAgICAgICAgICAgPC92YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgIDxjb250YWluZXIgeD0iMCIgeT0iMjA5IiB3aWR0aD0iMTcwIiBoZWlnaHQ9IjEiIHBhcmFtcz0iMTYiIHN0eWxlPSIwIiBuYW1lPSJvd25lcl9zcGFjZXIiIGNvbG9yPSIweGZmZmYzMzMzMzMiIGJhY2tncm91bmQ9InRydWUiLz4NCiAgICAgICAgICAgICAgICA8cmVnaW9uIHg9IjAiIHk9IjIxNSIgd2lkdGg9IjE3MCIgaGVpZ2h0PSIxNyIgcGFyYW1zPSIxNyIgc3R5bGU9IjAiIG5hbWU9Im93bmVyX3JlZ2lvbiIgdHJlc2hvbGQ9IjAiPg0KICAgICAgICAgICAgICAgICAgPGNoaWxkcmVuPg0KICAgICAgICAgICAgICAgICAgICA8aWNvbiB4PSIwIiB5PSIyIiB3aWR0aD0iMjAiIGhlaWdodD0iMTUiIHBhcmFtcz0iMTYiIHN0eWxlPSIyMSIgbmFtZT0ib3duZXJfbGluayIvPg0KICAgICAgICAgICAgICAgICAgICA8c3RhdGljX2JpdG1hcCB4PSIwIiB5PSIwIiB3aWR0aD0iMTUiIGhlaWdodD0iMTUiIHBhcmFtcz0iMTYiIHN0eWxlPSIzIiBuYW1lPSJiY3dfaWNvbiIgdmlzaWJsZT0iZmFsc2UiPg0KICAgICAgICAgICAgICAgICAgICAgIDx2YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0iYXNzZXRfdXJpIiB2YWx1ZT0iJHtpbWFnZS5saWJyYXJ5LnVybH0vY2F0YWxvZ3VlL2ljb25fMTkzLnBuZyIgdHlwZT0iU3RyaW5nIi8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0iZml0X3NpemVfdG9fY29udGVudHMiIHZhbHVlPSJ0cnVlIiB0eXBlPSJCb29sZWFuIi8+DQogICAgICAgICAgICAgICAgICAgICAgPC92YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgICAgIDwvc3RhdGljX2JpdG1hcD4NCiAgICAgICAgICAgICAgICAgICAgPHRleHQgeD0iMjAiIHk9IjAiIHdpZHRoPSIxNTAiIGhlaWdodD0iMTUiIHBhcmFtcz0iMTYiIHN0eWxlPSIwIiBuYW1lPSJvd25lcl9uYW1lIj4NCiAgICAgICAgICAgICAgICAgICAgICA8dmFyaWFibGVzPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9InRleHRfY29sb3IiIHZhbHVlPSIweGZmZmZmZiIgdHlwZT0iaGV4Ii8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0ibW91c2Vfd2hlZWxfZW5hYmxlZCIgdmFsdWU9ImZhbHNlIiB0eXBlPSJCb29sZWFuIi8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0ic2hhcnBuZXNzIiB2YWx1ZT0iMCIgdHlwZT0iTnVtYmVyIi8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0idGhpY2tuZXNzIiB2YWx1ZT0iMCIgdHlwZT0iTnVtYmVyIi8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0id29yZF93cmFwIiB2YWx1ZT0idHJ1ZSIgdHlwZT0iQm9vbGVhbiIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9Imtlcm5pbmciIHZhbHVlPSJmYWxzZSIgdHlwZT0iQm9vbGVhbiIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9InNwYWNpbmciIHZhbHVlPSIwIiB0eXBlPSJOdW1iZXIiLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJsZWFkaW5nIiB2YWx1ZT0iMCIgdHlwZT0iTnVtYmVyIi8+DQogICAgICAgICAgICAgICAgICAgICAgPC92YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY2hpbGRyZW4+DQogICAgICAgICAgICAgICAgPC9yZWdpb24+DQogICAgICAgICAgICAgICAgPGNvbnRhaW5lciB4PSIwIiB5PSIyMzciIHdpZHRoPSIxNzAiIGhlaWdodD0iMSIgcGFyYW1zPSIxNiIgc3R5bGU9IjAiIG5hbWU9Imdyb3VwX2RldGFpbHNfc3BhY2VyIiBjb2xvcj0iMHhmZmZmMzMzMzMzIiBiYWNrZ3JvdW5kPSJ0cnVlIi8+DQogICAgICAgICAgICAgICAgPHJlZ2lvbiB4PSIwIiB5PSIyNDMiIHdpZHRoPSIxNzAiIGhlaWdodD0iNDAiIHBhcmFtcz0iMTciIHN0eWxlPSIwIiBuYW1lPSJncm91cF9kZXRhaWxzX2NvbnRhaW5lciIgdHJlc2hvbGQ9IjAiPg0KICAgICAgICAgICAgICAgICAgPGNoaWxkcmVuPg0KICAgICAgICAgICAgICAgICAgICA8d2lkZ2V0IHg9IjAiIHk9IjAiIHdpZHRoPSI0MCIgaGVpZ2h0PSI0MCIgcGFyYW1zPSIxNiIgc3R5bGU9IjAiIG5hbWU9Imdyb3VwX2JhZGdlX2ltYWdlIj4NCiAgICAgICAgICAgICAgICAgICAgICA8dmFyaWFibGVzPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9IndpZGdldF90eXBlIiB2YWx1ZT0iYmFkZ2VfaW1hZ2UiIHR5cGU9IlN0cmluZyIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9ImJhZGdlX2ltYWdlOnR5cGUiIHZhbHVlPSJncm91cCIgdHlwZT0iU3RyaW5nIi8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0iYmFkZ2VfaW1hZ2U6cGl2b3RfcG9pbnQiIHZhbHVlPSJjZW50ZXIiIHR5cGU9IlN0cmluZyIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9ImJhZGdlX2ltYWdlOnN0cmV0Y2hlZF94IiB2YWx1ZT0iZmFsc2UiIHR5cGU9IkJvb2xlYW4iLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJiYWRnZV9pbWFnZTpzdHJldGNoZWRfeSIgdmFsdWU9ImZhbHNlIiB0eXBlPSJCb29sZWFuIi8+DQogICAgICAgICAgICAgICAgICAgICAgPC92YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgICAgIDwvd2lkZ2V0Pg0KICAgICAgICAgICAgICAgICAgICA8dGV4dCB4PSI0NSIgeT0iMTAiIHdpZHRoPSIxMjgiIGhlaWdodD0iMzciIHBhcmFtcz0iMTYiIHN0eWxlPSIwIiBuYW1lPSJncm91cF9uYW1lIj4NCiAgICAgICAgICAgICAgICAgICAgICA8dmFyaWFibGVzPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9InRleHRfY29sb3IiIHZhbHVlPSIweGZmZmZmZiIgdHlwZT0iaGV4Ii8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0ibW91c2Vfd2hlZWxfZW5hYmxlZCIgdmFsdWU9ImZhbHNlIiB0eXBlPSJCb29sZWFuIi8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0ic2hhcnBuZXNzIiB2YWx1ZT0iMCIgdHlwZT0iTnVtYmVyIi8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0idGhpY2tuZXNzIiB2YWx1ZT0iMCIgdHlwZT0iTnVtYmVyIi8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0id29yZF93cmFwIiB2YWx1ZT0idHJ1ZSIgdHlwZT0iQm9vbGVhbiIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9Imtlcm5pbmciIHZhbHVlPSJmYWxzZSIgdHlwZT0iQm9vbGVhbiIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9InNwYWNpbmciIHZhbHVlPSIwIiB0eXBlPSJOdW1iZXIiLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJsZWFkaW5nIiB2YWx1ZT0iMCIgdHlwZT0iTnVtYmVyIi8+DQogICAgICAgICAgICAgICAgICAgICAgPC92YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY2hpbGRyZW4+DQogICAgICAgICAgICAgICAgICA8dmFyaWFibGVzPg0KICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0idG9vbF90aXBfY2FwdGlvbiIgdmFsdWU9IiR7aW5mb3N0YW5kLmdyb3VwLmxpbmsudG9vbHRpcH0iIHR5cGU9IlN0cmluZyIvPg0KICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0idG9vbF90aXBfZGVsYXkiIHZhbHVlPSIxMDAiIHR5cGU9InVpbnQiLz4NCiAgICAgICAgICAgICAgICAgIDwvdmFyaWFibGVzPg0KICAgICAgICAgICAgICAgIDwvcmVnaW9uPg0KICAgICAgICAgICAgICAgIDx0ZXh0IHg9IjAiIHk9IjI4OCIgd2lkdGg9IjE3MCIgaGVpZ2h0PSIyMyIgcGFyYW1zPSIxNiIgc3R5bGU9IjAiIG5hbWU9ImV4cGlyYXRpb25fdGV4dCIgY2FwdGlvbj0iJTI0JTdCaW5mb3N0YW5kLnJlbnQuZXhwaXJhdGlvbiU3RCI+DQogICAgICAgICAgICAgICAgICA8dmFyaWFibGVzPg0KICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0idGV4dF9jb2xvciIgdmFsdWU9IjB4ZmZmZmZmIiB0eXBlPSJoZXgiLz4NCiAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9Im1hcmdpbl90b3AiIHZhbHVlPSI2IiB0eXBlPSJpbnQiLz4NCiAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9Im1vdXNlX3doZWVsX2VuYWJsZWQiIHZhbHVlPSJmYWxzZSIgdHlwZT0iQm9vbGVhbiIvPg0KICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0ic2hhcnBuZXNzIiB2YWx1ZT0iMCIgdHlwZT0iTnVtYmVyIi8+DQogICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJ0aGlja25lc3MiIHZhbHVlPSIwIiB0eXBlPSJOdW1iZXIiLz4NCiAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9IndvcmRfd3JhcCIgdmFsdWU9InRydWUiIHR5cGU9IkJvb2xlYW4iLz4NCiAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9Imtlcm5pbmciIHZhbHVlPSJmYWxzZSIgdHlwZT0iQm9vbGVhbiIvPg0KICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0ic3BhY2luZyIgdmFsdWU9IjAiIHR5cGU9Ik51bWJlciIvPg0KICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0ibGVhZGluZyIgdmFsdWU9IjAiIHR5cGU9Ik51bWJlciIvPg0KICAgICAgICAgICAgICAgICAgPC92YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgIDxpdGVtbGlzdF9ob3Jpem9udGFsIHg9IjAiIHk9IjMxNiIgd2lkdGg9IjE3MCIgaGVpZ2h0PSIyMiIgcGFyYW1zPSIxNiIgc3R5bGU9IjEwMCIgbmFtZT0icHVyY2hhc2VfYnV0dG9ucyI+DQogICAgICAgICAgICAgICAgICA8Y2hpbGRyZW4+DQogICAgICAgICAgICAgICAgICAgIDxidXR0b24geD0iMCIgeT0iMCIgd2lkdGg9IjEyNSIgaGVpZ2h0PSIyMiIgcGFyYW1zPSIxMzEwODkiIHN0eWxlPSIwIiBuYW1lPSJjYXRhbG9nX2J1dHRvbiIgY2FwdGlvbj0iJTI0JTdCaW5mb3N0YW5kLmJ1dHRvbi5idXklN0QiIHRhZ3M9ImNhdGFsb2ciLz4NCiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB4PSIxMzAiIHk9IjAiIHdpZHRoPSIxMjgiIGhlaWdodD0iMjIiIHBhcmFtcz0iMTMxMDg5IiBzdHlsZT0iMCIgbmFtZT0icmVudF9idXR0b24iIGNhcHRpb249IiUyNCU3QmluZm9zdGFuZC5idXR0b24ucmVudCU3RCIvPg0KICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHg9IjI2MyIgeT0iMCIgd2lkdGg9IjE0MSIgaGVpZ2h0PSIyMiIgcGFyYW1zPSIxMzEwODkiIHN0eWxlPSIwIiBuYW1lPSJleHRlbmRfYnV0dG9uIiBjYXB0aW9uPSIlMjQlN0JpbmZvc3RhbmQuYnV0dG9uLmV4dGVuZCU3RCIvPg0KICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHg9IjQwOSIgeT0iMCIgd2lkdGg9IjE0MSIgaGVpZ2h0PSIyMiIgcGFyYW1zPSIxMzEwODkiIHN0eWxlPSIwIiBuYW1lPSJidXlvdXRfYnV0dG9uIiBjYXB0aW9uPSIlMjQlN0JpbmZvc3RhbmQuYnV0dG9uLmJ1eW91dCU3RCIvPg0KICAgICAgICAgICAgICAgICAgPC9jaGlsZHJlbj4NCiAgICAgICAgICAgICAgICAgIDx2YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJzcGFjaW5nIiB2YWx1ZT0iNSIgdHlwZT0iaW50Ii8+DQogICAgICAgICAgICAgICAgICA8L3ZhcmlhYmxlcz4NCiAgICAgICAgICAgICAgICA8L2l0ZW1saXN0X2hvcml6b250YWw+DQogICAgICAgICAgICAgICAgPGNvbnRhaW5lciB4PSIwIiB5PSIzNDMiIHdpZHRoPSIxNzAiIGhlaWdodD0iMSIgcGFyYW1zPSIxNiIgc3R5bGU9IjAiIG5hbWU9ImZ1cm5pX2RldGFpbHNfc3BhY2VyIiBjb2xvcj0iMHhmZmZmMzMzMzMzIiBiYWNrZ3JvdW5kPSJ0cnVlIi8+DQogICAgICAgICAgICAgICAgPHRleHQgeD0iMCIgeT0iMzQ5IiB3aWR0aD0iMTcwIiBoZWlnaHQ9IjQwIiBwYXJhbXM9IjE2IiBzdHlsZT0iMCIgbmFtZT0iZnVybmlfZGV0YWlsc190ZXh0IiBjYXB0aW9uPSJGdXJuaSUyMGRldGFpbHMiPg0KICAgICAgICAgICAgICAgICAgPHZhcmlhYmxlcz4NCiAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9InRleHRfY29sb3IiIHZhbHVlPSIweGZmZmZmZiIgdHlwZT0iaGV4Ii8+DQogICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJtb3VzZV93aGVlbF9lbmFibGVkIiB2YWx1ZT0iZmFsc2UiIHR5cGU9IkJvb2xlYW4iLz4NCiAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9InNoYXJwbmVzcyIgdmFsdWU9IjAiIHR5cGU9Ik51bWJlciIvPg0KICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0idGhpY2tuZXNzIiB2YWx1ZT0iMCIgdHlwZT0iTnVtYmVyIi8+DQogICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJ3b3JkX3dyYXAiIHZhbHVlPSJ0cnVlIiB0eXBlPSJCb29sZWFuIi8+DQogICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJrZXJuaW5nIiB2YWx1ZT0iZmFsc2UiIHR5cGU9IkJvb2xlYW4iLz4NCiAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9InNwYWNpbmciIHZhbHVlPSIwIiB0eXBlPSJOdW1iZXIiLz4NCiAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9ImxlYWRpbmciIHZhbHVlPSIwIiB0eXBlPSJOdW1iZXIiLz4NCiAgICAgICAgICAgICAgICAgIDwvdmFyaWFibGVzPg0KICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgPC9jaGlsZHJlbj4NCiAgICAgICAgICAgICAgPHZhcmlhYmxlcz4NCiAgICAgICAgICAgICAgICA8dmFyIGtleT0ic3BhY2luZyIgdmFsdWU9IjUiIHR5cGU9ImludCIvPg0KICAgICAgICAgICAgICAgIDx2YXIga2V5PSJzY2FsZV90b19maXRfaXRlbXMiIHZhbHVlPSJ0cnVlIiB0eXBlPSJCb29sZWFuIi8+DQogICAgICAgICAgICAgICAgPHZhciBrZXk9InJlc2l6ZV9vbl9pdGVtX3VwZGF0ZSIgdmFsdWU9InRydWUiIHR5cGU9IkJvb2xlYW4iLz4NCiAgICAgICAgICAgICAgPC92YXJpYWJsZXM+DQogICAgICAgICAgICA8L2l0ZW1saXN0X3ZlcnRpY2FsPg0KICAgICAgICAgIDwvY2hpbGRyZW4+DQogICAgICAgIDwvYm9yZGVyPg0KICAgICAgICA8Ym9yZGVyIHg9IjAiIHk9IjQwMCIgd2lkdGg9IjE5MCIgaGVpZ2h0PSI2MiIgcGFyYW1zPSIxNyIgc3R5bGU9IjIiIG5hbWU9ImN1c3RvbV92YXJpYWJsZXMiIGNvbG9yPSIweDA5OTk5OTkiPg0KICAgICAgICAgIDxjaGlsZHJlbj4NCiAgICAgICAgICAgIDxib3JkZXIgeD0iMyIgeT0iMyIgd2lkdGg9IjE4NCIgaGVpZ2h0PSI1NiIgcGFyYW1zPSI4Mzg4NjI0IiBzdHlsZT0iMyIgY29sb3I9IjB4MDMzMzMzMyI+DQogICAgICAgICAgICAgIDxjaGlsZHJlbj4NCiAgICAgICAgICAgICAgICA8YnV0dG9uIHg9IjU1IiB5PSI0IiB3aWR0aD0iNzUiIGhlaWdodD0iMjQiIHBhcmFtcz0iMTMxMjgxIiBzdHlsZT0iMyIgbmFtZT0ic2V0X3ZhbHVlcyIgY2FwdGlvbj0iU2V0JTIwdmFsdWVzIi8+DQogICAgICAgICAgICAgICAgPGl0ZW1saXN0X3ZlcnRpY2FsIHg9IjAiIHk9IjMyIiB3aWR0aD0iMjE0IiBoZWlnaHQ9IjI2IiBwYXJhbXM9Ijg1MzYwODAiIHN0eWxlPSIzIiBuYW1lPSJ2YXJpYWJsZV9saXN0Ij4NCiAgICAgICAgICAgICAgICAgIDxjaGlsZHJlbj4NCiAgICAgICAgICAgICAgICAgICAgPGNvbnRhaW5lciB4PSIwIiB5PSIwIiB3aWR0aD0iMTgzIiBoZWlnaHQ9IjI2IiBwYXJhbXM9IjE2IiBzdHlsZT0iMyI+DQogICAgICAgICAgICAgICAgICAgICAgPGNoaWxkcmVuPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIHg9IjEiIHk9IjIiIHdpZHRoPSI0MSIgaGVpZ2h0PSIxNyIgcGFyYW1zPSIxNiIgc3R5bGU9IjMiIG5hbWU9Im5hbWUiIGNhcHRpb249Ik5hbWUlM0EiPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8dmFyaWFibGVzPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJ0ZXh0X2NvbG9yIiB2YWx1ZT0iMHhmZmZmZmYiIHR5cGU9ImhleCIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8L3ZhcmlhYmxlcz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvbGFiZWw+DQogICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgeD0iODAiIHk9IjIiIHdpZHRoPSIxMDAiIGhlaWdodD0iMTciIHBhcmFtcz0iMSIgc3R5bGU9IjMiIG5hbWU9InZhbHVlIj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHZhcmlhYmxlcz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0ic3BhY2luZyIgdmFsdWU9IjAiIHR5cGU9Ik51bWJlciIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJsZWFkaW5nIiB2YWx1ZT0iMCIgdHlwZT0iTnVtYmVyIi8+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDwvdmFyaWFibGVzPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9pbnB1dD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxib3JkZXIgeD0iODAiIHk9IjAiIHdpZHRoPSIxMDAiIGhlaWdodD0iMjAiIHBhcmFtcz0iMTYiIHN0eWxlPSIzIiBjb2xvcj0iMHgwY2NjY2NjIi8+DQogICAgICAgICAgICAgICAgICAgICAgPC9jaGlsZHJlbj4NCiAgICAgICAgICAgICAgICAgICAgPC9jb250YWluZXI+DQogICAgICAgICAgICAgICAgICA8L2NoaWxkcmVuPg0KICAgICAgICAgICAgICAgIDwvaXRlbWxpc3RfdmVydGljYWw+DQogICAgICAgICAgICAgIDwvY2hpbGRyZW4+DQogICAgICAgICAgICA8L2JvcmRlcj4NCiAgICAgICAgICA8L2NoaWxkcmVuPg0KICAgICAgICA8L2JvcmRlcj4NCiAgICAgICAgPGl0ZW1saXN0X2hvcml6b250YWwgeD0iMCIgeT0iNDcyIiB3aWR0aD0iMTI4MCIgaGVpZ2h0PSIyNSIgcGFyYW1zPSIxNiIgc3R5bGU9IjAiIG5hbWU9ImJ1dHRvbl9saXN0Ij4NCiAgICAgICAgICA8Y2hpbGRyZW4+DQogICAgICAgICAgICA8YnV0dG9uIHg9IjAiIHk9IjAiIHdpZHRoPSIxMzIiIGhlaWdodD0iMjUiIHBhcmFtcz0iMTMxMDg5IiBzdHlsZT0iMSIgbmFtZT0ibW92ZSIgY2FwdGlvbj0iJTI0JTdCaW5mb3N0YW5kLmJ1dHRvbi5tb3ZlJTdEIi8+DQogICAgICAgICAgICA8YnV0dG9uIHg9IjE0MiIgeT0iMCIgd2lkdGg9IjEzOSIgaGVpZ2h0PSIyNSIgcGFyYW1zPSIxMzEwODkiIHN0eWxlPSIxIiBuYW1lPSJyb3RhdGUiIGNhcHRpb249IiUyNCU3QmluZm9zdGFuZC5idXR0b24ucm90YXRlJTdEIi8+DQogICAgICAgICAgICA8YnV0dG9uIHg9IjI5MSIgeT0iMCIgd2lkdGg9IjEzNyIgaGVpZ2h0PSIyNSIgcGFyYW1zPSIxMzEwODkiIHN0eWxlPSIxIiBuYW1lPSJwaWNrdXAiIGNhcHRpb249IiUyNCU3QmluZm9zdGFuZC5idXR0b24ucGlja3VwJTdEIi8+DQogICAgICAgICAgICA8YnV0dG9uIHg9IjQzOCIgeT0iMCIgd2lkdGg9IjE3MyIgaGVpZ2h0PSIyNSIgcGFyYW1zPSIxMzEwODkiIHN0eWxlPSIxIiBuYW1lPSJzYXZlX2JyYW5kaW5nX2NvbmZpZ3VyYXRpb24iIGNhcHRpb249IiUyNCU3QmluZm9zdGFuZC5idXR0b24uc2F2ZWJyYW5kaW5nJTdEIi8+DQogICAgICAgICAgICA8YnV0dG9uIHg9IjYyMSIgeT0iMCIgd2lkdGg9IjEyNSIgaGVpZ2h0PSIyNSIgcGFyYW1zPSIxMzEwODkiIHN0eWxlPSIxIiBuYW1lPSJ1c2UiIGNhcHRpb249IiUyNCU3QmluZm9zdGFuZC5idXR0b24udXNlJTdEIi8+DQogICAgICAgICAgPC9jaGlsZHJlbj4NCiAgICAgICAgICA8dmFyaWFibGVzPg0KICAgICAgICAgICAgPHZhciBrZXk9InNwYWNpbmciIHZhbHVlPSIxMCIgdHlwZT0iaW50Ii8+DQogICAgICAgICAgPC92YXJpYWJsZXM+DQogICAgICAgIDwvaXRlbWxpc3RfaG9yaXpvbnRhbD4NCiAgICAgIDwvY2hpbGRyZW4+DQogICAgICA8dmFyaWFibGVzPg0KICAgICAgICA8dmFyIGtleT0ic3BhY2luZyIgdmFsdWU9IjEwIiB0eXBlPSJpbnQiLz4NCiAgICAgICAgPHZhciBrZXk9InNjYWxlX3RvX2ZpdF9pdGVtcyIgdmFsdWU9InRydWUiIHR5cGU9IkJvb2xlYW4iLz4NCiAgICAgICAgPHZhciBrZXk9InJlc2l6ZV9vbl9pdGVtX3VwZGF0ZSIgdmFsdWU9InRydWUiIHR5cGU9IkJvb2xlYW4iLz4NCiAgICAgIDwvdmFyaWFibGVzPg0KICAgIDwvaXRlbWxpc3RfdmVydGljYWw+DQogIDwvd2luZG93Pg0KPC9sYXlvdXQ+";

        private const string USERVIEW_TEST_XML =
            "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4NCjxsYXlvdXQgbmFtZT0idXNlcnZpZXdfdGVzdCIgd2lkdGg9IjEwMzYiIGhlaWdodD0iNDAwIiB2ZXJzaW9uPSIwLjEiIHVpZD0iQkQ4NjRGNjItNUVEQy0wNEU3LUI0OEEtNjJFRUU2QUM4RDU4Ij4NCiAgPHdpbmRvdz4NCiAgICA8aXRlbWxpc3RfdmVydGljYWwgeD0iMCIgeT0iMCIgd2lkdGg9IjEwMzYiIGhlaWdodD0iNDAwIiBwYXJhbXM9IjE2IiBzdHlsZT0iMCI+DQogICAgICA8Y2hpbGRyZW4+DQogICAgICAgIDxib3JkZXIgeD0iMCIgeT0iMCIgd2lkdGg9IjE5MCIgaGVpZ2h0PSIzNTciIHBhcmFtcz0iMTciIHN0eWxlPSIxIiBuYW1lPSJpbmZvX2JvcmRlciI+DQogICAgICAgICAgPGNoaWxkcmVuPg0KICAgICAgICAgICAgPGJpdG1hcCB4PSI4IiB5PSIxMSIgd2lkdGg9IjE2IiBoZWlnaHQ9IjE1IiBwYXJhbXM9IjE3IiBzdHlsZT0iMCIgbmFtZT0iaG9tZV9pY29uIiB0cmVzaG9sZD0iMCIvPg0KICAgICAgICAgICAgPGNsb3NlYnV0dG9uIHg9IjE2OCIgeT0iNiIgd2lkdGg9IjE4IiBoZWlnaHQ9IjE2IiBwYXJhbXM9IjE3IiBzdHlsZT0iMSIgYmFja2dyb3VuZD0idHJ1ZSIgdHJlc2hvbGQ9IjAiIHRhZ3M9ImNsb3NlIi8+DQogICAgICAgICAgICA8aXRlbWxpc3RfdmVydGljYWwgeD0iMTAiIHk9IjEwIiB3aWR0aD0iMTcwIiBoZWlnaHQ9IjM0MSIgcGFyYW1zPSIxNiIgc3R5bGU9IjAiIG5hbWU9ImluZm9zdGFuZF9lbGVtZW50X2xpc3QiIGJhY2tncm91bmQ9InRydWUiPg0KICAgICAgICAgICAgICA8Y2hpbGRyZW4+DQogICAgICAgICAgICAgICAgPHJlZ2lvbiB4PSIxOCIgeT0iMCIgd2lkdGg9IjEzNSIgaGVpZ2h0PSIxMiIgcGFyYW1zPSIxNyIgc3R5bGU9IjAiIG5hbWU9InByb2ZpbGVfbGluayIgdHJlc2hvbGQ9IjAiPg0KICAgICAgICAgICAgICAgICAgPGNoaWxkcmVuPg0KICAgICAgICAgICAgICAgICAgICA8dGV4dCB4PSIwIiB5PSIwIiB3aWR0aD0iNCIgaGVpZ2h0PSI0IiBwYXJhbXM9IjE0NiIgc3R5bGU9IjAiIG5hbWU9Im5hbWVfdGV4dCIgY29sb3I9IjB4MDNkM2QzZCIgYmFja2dyb3VuZD0idHJ1ZSI+DQogICAgICAgICAgICAgICAgICAgICAgPHZhcmlhYmxlcz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJhdXRvX3NpemUiIHZhbHVlPSJsZWZ0IiB0eXBlPSJTdHJpbmciLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJmb250X2ZhY2UiIHZhbHVlPSJWb2x0ZXIgQm9sZCIgdHlwZT0iU3RyaW5nIi8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0idGV4dF9jb2xvciIgdmFsdWU9IjB4ZmZmZmZmIiB0eXBlPSJoZXgiLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJtb3VzZV93aGVlbF9lbmFibGVkIiB2YWx1ZT0iZmFsc2UiIHR5cGU9IkJvb2xlYW4iLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJzaGFycG5lc3MiIHZhbHVlPSIwIiB0eXBlPSJOdW1iZXIiLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJ0aGlja25lc3MiIHZhbHVlPSIwIiB0eXBlPSJOdW1iZXIiLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJrZXJuaW5nIiB2YWx1ZT0iZmFsc2UiIHR5cGU9IkJvb2xlYW4iLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJzcGFjaW5nIiB2YWx1ZT0iMCIgdHlwZT0iTnVtYmVyIi8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0ibGVhZGluZyIgdmFsdWU9IjAiIHR5cGU9Ik51bWJlciIvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvdmFyaWFibGVzPg0KICAgICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8L2NoaWxkcmVuPg0KICAgICAgICAgICAgICAgICAgPHZhcmlhYmxlcz4NCiAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9InRvb2xfdGlwX2NhcHRpb24iIHZhbHVlPSIke2luZm9zdGFuZC5wcm9maWxlLmxpbmsudG9vbHRpcH0iIHR5cGU9IlN0cmluZyIvPg0KICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0idG9vbF90aXBfZGVsYXkiIHZhbHVlPSIxMDAiIHR5cGU9InVpbnQiLz4NCiAgICAgICAgICAgICAgICAgIDwvdmFyaWFibGVzPg0KICAgICAgICAgICAgICAgIDwvcmVnaW9uPg0KICAgICAgICAgICAgICAgIDxjb250YWluZXIgeD0iMCIgeT0iMTUiIHdpZHRoPSIxNzAiIGhlaWdodD0iMSIgcGFyYW1zPSIxNiIgc3R5bGU9IjAiIG5hbWU9ImltYWdlc19zcGFjZXIiIGNvbG9yPSIweGZmZmYzMzMzMzMiIGJhY2tncm91bmQ9InRydWUiLz4NCiAgICAgICAgICAgICAgICA8Y29udGFpbmVyIHg9Ii0xNiIgeT0iMTkiIHdpZHRoPSIxOTMiIGhlaWdodD0iMTMyIiBwYXJhbXM9IjE2IiBzdHlsZT0iMCIgbmFtZT0iaW1hZ2VfYW5kX2JhZGdlc19jb250YWluZXIiIGNvbG9yPSIweDA2ZDZkNmQiIGJhY2tncm91bmQ9InRydWUiPg0KICAgICAgICAgICAgICAgICAgPGNoaWxkcmVuPg0KICAgICAgICAgICAgICAgICAgICA8Ym9yZGVyIHg9IjE2IiB5PSIwIiB3aWR0aD0iNjciIGhlaWdodD0iMTMwIiBwYXJhbXM9IjE2IiBzdHlsZT0iMCIgbmFtZT0iZ3JleV9iZyIgY29sb3I9IjB4MDY2NjY2NiIvPg0KICAgICAgICAgICAgICAgICAgICA8cmVnaW9uIHg9IjE3IiB5PSIyIiB3aWR0aD0iNjYiIGhlaWdodD0iMTI3IiBwYXJhbXM9IjE3IiBzdHlsZT0iMCIgbmFtZT0iYXZhdGFyX2ltYWdlX3Byb2ZpbGVfbGluayIgdHJlc2hvbGQ9IjAiPg0KICAgICAgICAgICAgICAgICAgICAgIDxjaGlsZHJlbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx3aWRnZXQgeD0iMTYiIHk9IjIxIiB3aWR0aD0iMzQiIGhlaWdodD0iODQiIHBhcmFtcz0iMzI4MiIgc3R5bGU9IjAiIG5hbWU9ImF2YXRhcl9pbWFnZSI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDx2YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9IndpZGdldF90eXBlIiB2YWx1ZT0iYXZhdGFyX2ltYWdlIiB0eXBlPSJTdHJpbmciLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0iYXZhdGFyX2ltYWdlOmNyb3BwZWQiIHZhbHVlPSJ0cnVlIiB0eXBlPSJCb29sZWFuIi8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9ImF2YXRhcl9pbWFnZTpkaXJlY3Rpb24iIHZhbHVlPSJzb3V0aHdlc3QiIHR5cGU9IlN0cmluZyIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8L3ZhcmlhYmxlcz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvd2lkZ2V0Pg0KICAgICAgICAgICAgICAgICAgICAgIDwvY2hpbGRyZW4+DQogICAgICAgICAgICAgICAgICAgICAgPHZhcmlhYmxlcz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJ0b29sX3RpcF9jYXB0aW9uIiB2YWx1ZT0iJHtpbmZvc3RhbmQucHJvZmlsZS5saW5rLnRvb2x0aXB9IiB0eXBlPSJTdHJpbmciLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJ0b29sX3RpcF9kZWxheSIgdmFsdWU9IjEwMCIgdHlwZT0idWludCIvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvdmFyaWFibGVzPg0KICAgICAgICAgICAgICAgICAgICA8L3JlZ2lvbj4NCiAgICAgICAgICAgICAgICAgICAgPHdpZGdldCB4PSI4OCIgeT0iMSIgd2lkdGg9IjQyIiBoZWlnaHQ9IjQyIiBwYXJhbXM9IjE3IiBzdHlsZT0iMCIgbmFtZT0iYmFkZ2VfMCIgdHJlc2hvbGQ9IjAiPg0KICAgICAgICAgICAgICAgICAgICAgIDx2YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0id2lkZ2V0X3R5cGUiIHZhbHVlPSJiYWRnZV9pbWFnZSIgdHlwZT0iU3RyaW5nIi8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0iYmFkZ2VfaW1hZ2U6cGl2b3RfcG9pbnQiIHZhbHVlPSJjZW50ZXIiIHR5cGU9IlN0cmluZyIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9ImJhZGdlX2ltYWdlOnN0cmV0Y2hlZF94IiB2YWx1ZT0iZmFsc2UiIHR5cGU9IkJvb2xlYW4iLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJiYWRnZV9pbWFnZTpzdHJldGNoZWRfeSIgdmFsdWU9ImZhbHNlIiB0eXBlPSJCb29sZWFuIi8+DQogICAgICAgICAgICAgICAgICAgICAgPC92YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgICAgIDwvd2lkZ2V0Pg0KICAgICAgICAgICAgICAgICAgICA8d2lkZ2V0IHg9IjEzMSIgeT0iMSIgd2lkdGg9IjQyIiBoZWlnaHQ9IjQyIiBwYXJhbXM9IjE3IiBzdHlsZT0iMCIgbmFtZT0iYmFkZ2VfZ3JvdXAiIHRyZXNob2xkPSIwIj4NCiAgICAgICAgICAgICAgICAgICAgICA8dmFyaWFibGVzPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9IndpZGdldF90eXBlIiB2YWx1ZT0iYmFkZ2VfaW1hZ2UiIHR5cGU9IlN0cmluZyIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9ImJhZGdlX2ltYWdlOnR5cGUiIHZhbHVlPSJncm91cCIgdHlwZT0iU3RyaW5nIi8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0iYmFkZ2VfaW1hZ2U6cGl2b3RfcG9pbnQiIHZhbHVlPSJjZW50ZXIiIHR5cGU9IlN0cmluZyIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9ImJhZGdlX2ltYWdlOnN0cmV0Y2hlZF94IiB2YWx1ZT0iZmFsc2UiIHR5cGU9IkJvb2xlYW4iLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJiYWRnZV9pbWFnZTpzdHJldGNoZWRfeSIgdmFsdWU9ImZhbHNlIiB0eXBlPSJCb29sZWFuIi8+DQogICAgICAgICAgICAgICAgICAgICAgPC92YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgICAgIDwvd2lkZ2V0Pg0KICAgICAgICAgICAgICAgICAgICA8d2lkZ2V0IHg9Ijg4IiB5PSI0NCIgd2lkdGg9IjQyIiBoZWlnaHQ9IjQyIiBwYXJhbXM9IjE3IiBzdHlsZT0iMCIgbmFtZT0iYmFkZ2VfMSIgdHJlc2hvbGQ9IjAiPg0KICAgICAgICAgICAgICAgICAgICAgIDx2YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0id2lkZ2V0X3R5cGUiIHZhbHVlPSJiYWRnZV9pbWFnZSIgdHlwZT0iU3RyaW5nIi8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0iYmFkZ2VfaW1hZ2U6cGl2b3RfcG9pbnQiIHZhbHVlPSJjZW50ZXIiIHR5cGU9IlN0cmluZyIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9ImJhZGdlX2ltYWdlOnN0cmV0Y2hlZF94IiB2YWx1ZT0iZmFsc2UiIHR5cGU9IkJvb2xlYW4iLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJiYWRnZV9pbWFnZTpzdHJldGNoZWRfeSIgdmFsdWU9ImZhbHNlIiB0eXBlPSJCb29sZWFuIi8+DQogICAgICAgICAgICAgICAgICAgICAgPC92YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgICAgIDwvd2lkZ2V0Pg0KICAgICAgICAgICAgICAgICAgICA8d2lkZ2V0IHg9IjEzMSIgeT0iNDQiIHdpZHRoPSI0MiIgaGVpZ2h0PSI0MiIgcGFyYW1zPSIxNyIgc3R5bGU9IjAiIG5hbWU9ImJhZGdlXzIiIHRyZXNob2xkPSIwIj4NCiAgICAgICAgICAgICAgICAgICAgICA8dmFyaWFibGVzPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9IndpZGdldF90eXBlIiB2YWx1ZT0iYmFkZ2VfaW1hZ2UiIHR5cGU9IlN0cmluZyIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9ImJhZGdlX2ltYWdlOnBpdm90X3BvaW50IiB2YWx1ZT0iY2VudGVyIiB0eXBlPSJTdHJpbmciLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJiYWRnZV9pbWFnZTpzdHJldGNoZWRfeCIgdmFsdWU9ImZhbHNlIiB0eXBlPSJCb29sZWFuIi8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0iYmFkZ2VfaW1hZ2U6c3RyZXRjaGVkX3kiIHZhbHVlPSJmYWxzZSIgdHlwZT0iQm9vbGVhbiIvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvdmFyaWFibGVzPg0KICAgICAgICAgICAgICAgICAgICA8L3dpZGdldD4NCiAgICAgICAgICAgICAgICAgICAgPHdpZGdldCB4PSI4OCIgeT0iODciIHdpZHRoPSI0MiIgaGVpZ2h0PSI0MiIgcGFyYW1zPSIxNyIgc3R5bGU9IjAiIG5hbWU9ImJhZGdlXzMiIHRyZXNob2xkPSIwIj4NCiAgICAgICAgICAgICAgICAgICAgICA8dmFyaWFibGVzPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9IndpZGdldF90eXBlIiB2YWx1ZT0iYmFkZ2VfaW1hZ2UiIHR5cGU9IlN0cmluZyIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9ImJhZGdlX2ltYWdlOnBpdm90X3BvaW50IiB2YWx1ZT0iY2VudGVyIiB0eXBlPSJTdHJpbmciLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJiYWRnZV9pbWFnZTpzdHJldGNoZWRfeCIgdmFsdWU9ImZhbHNlIiB0eXBlPSJCb29sZWFuIi8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0iYmFkZ2VfaW1hZ2U6c3RyZXRjaGVkX3kiIHZhbHVlPSJmYWxzZSIgdHlwZT0iQm9vbGVhbiIvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvdmFyaWFibGVzPg0KICAgICAgICAgICAgICAgICAgICA8L3dpZGdldD4NCiAgICAgICAgICAgICAgICAgICAgPHdpZGdldCB4PSIxMzEiIHk9Ijg3IiB3aWR0aD0iNDIiIGhlaWdodD0iNDIiIHBhcmFtcz0iMTciIHN0eWxlPSIwIiBuYW1lPSJiYWRnZV80IiB0cmVzaG9sZD0iMCI+DQogICAgICAgICAgICAgICAgICAgICAgPHZhcmlhYmxlcz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJ3aWRnZXRfdHlwZSIgdmFsdWU9ImJhZGdlX2ltYWdlIiB0eXBlPSJTdHJpbmciLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJiYWRnZV9pbWFnZTpwaXZvdF9wb2ludCIgdmFsdWU9ImNlbnRlciIgdHlwZT0iU3RyaW5nIi8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0iYmFkZ2VfaW1hZ2U6c3RyZXRjaGVkX3giIHZhbHVlPSJmYWxzZSIgdHlwZT0iQm9vbGVhbiIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9ImJhZGdlX2ltYWdlOnN0cmV0Y2hlZF95IiB2YWx1ZT0iZmFsc2UiIHR5cGU9IkJvb2xlYW4iLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3ZhcmlhYmxlcz4NCiAgICAgICAgICAgICAgICAgICAgPC93aWRnZXQ+DQogICAgICAgICAgICAgICAgICA8L2NoaWxkcmVuPg0KICAgICAgICAgICAgICAgIDwvY29udGFpbmVyPg0KICAgICAgICAgICAgICAgIDxjb250YWluZXIgeD0iMCIgeT0iMTU0IiB3aWR0aD0iMTcwIiBoZWlnaHQ9IjEiIHBhcmFtcz0iMTYiIHN0eWxlPSIwIiBuYW1lPSJtb3R0b19zcGFjZXIiIGNvbG9yPSIweGZmZmYzMzMzMzMiIGJhY2tncm91bmQ9InRydWUiIHRyZXNob2xkPSIwIi8+DQogICAgICAgICAgICAgICAgPGJvcmRlciB4PSIwIiB5PSIxNTgiIHdpZHRoPSIxNzAiIGhlaWdodD0iNTciIHBhcmFtcz0iMTciIHN0eWxlPSIwIiBuYW1lPSJtb3R0b19jb250YWluZXIiIGNvbG9yPSIweDA2NjY2NjYiIHRyZXNob2xkPSIwIj4NCiAgICAgICAgICAgICAgICAgIDxjaGlsZHJlbj4NCiAgICAgICAgICAgICAgICAgICAgPHN0YXRpY19iaXRtYXAgeD0iMyIgeT0iMTkiIHdpZHRoPSIxNyIgaGVpZ2h0PSIxOCIgcGFyYW1zPSIzMDg4IiBzdHlsZT0iMCIgbmFtZT0iY2hhbmdlbW90dG8uaW1hZ2UiPg0KICAgICAgICAgICAgICAgICAgICAgIDx2YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0iYXNzZXRfdXJpIiB2YWx1ZT0iY29tbW9uX3NtYWxsX3BlbiIgdHlwZT0iU3RyaW5nIi8+DQogICAgICAgICAgICAgICAgICAgICAgPC92YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgICAgIDwvc3RhdGljX2JpdG1hcD4NCiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHg9IjIwIiB5PSIyIiB3aWR0aD0iMTQwIiBoZWlnaHQ9IjUzIiBwYXJhbXM9IjEiIHN0eWxlPSIwIiBuYW1lPSJtb3R0b190ZXh0Ij4NCiAgICAgICAgICAgICAgICAgICAgICA8dmFyaWFibGVzPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9ImFsd2F5c19zaG93X3NlbGVjdGlvbiIgdmFsdWU9InRydWUiIHR5cGU9IkJvb2xlYW4iLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJ0ZXh0X2NvbG9yIiB2YWx1ZT0iMHhmZmZmZmYiIHR5cGU9ImhleCIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9Im1hcmdpbl90b3AiIHZhbHVlPSI2IiB0eXBlPSJpbnQiLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJtb3VzZV93aGVlbF9lbmFibGVkIiB2YWx1ZT0iZmFsc2UiIHR5cGU9IkJvb2xlYW4iLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJtYXhfY2hhcnMiIHZhbHVlPSIzOCIgdHlwZT0iaW50Ii8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0ic2hhcnBuZXNzIiB2YWx1ZT0iMCIgdHlwZT0iTnVtYmVyIi8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0idGhpY2tuZXNzIiB2YWx1ZT0iMCIgdHlwZT0iTnVtYmVyIi8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0id29yZF93cmFwIiB2YWx1ZT0idHJ1ZSIgdHlwZT0iQm9vbGVhbiIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9Imtlcm5pbmciIHZhbHVlPSJmYWxzZSIgdHlwZT0iQm9vbGVhbiIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9InNwYWNpbmciIHZhbHVlPSIwIiB0eXBlPSJOdW1iZXIiLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJsZWFkaW5nIiB2YWx1ZT0iMCIgdHlwZT0iTnVtYmVyIi8+DQogICAgICAgICAgICAgICAgICAgICAgPC92YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgICAgIDwvaW5wdXQ+DQogICAgICAgICAgICAgICAgICA8L2NoaWxkcmVuPg0KICAgICAgICAgICAgICAgIDwvYm9yZGVyPg0KICAgICAgICAgICAgICAgIDxjb250YWluZXIgdmlzaWJsZT0iZmFsc2UiIHg9IjAiIHk9IjIxOCIgd2lkdGg9IjE3MCIgaGVpZ2h0PSIxIiBwYXJhbXM9IjE2IiBzdHlsZT0iMCIgbmFtZT0ic2NvcmVfc3BhY2VyIiBjb2xvcj0iMHhmZmZmMzMzMzMzIiBiYWNrZ3JvdW5kPSJ0cnVlIi8+DQogICAgICAgICAgICAgICAgPHRleHQgdmlzaWJsZT0iZmFsc2UiIHg9IjAiIHk9IjIyMiIgd2lkdGg9IjE3MCIgaGVpZ2h0PSIxNSIgcGFyYW1zPSIxNiIgc3R5bGU9IjAiIG5hbWU9InNjb3JlX3RleHQiIGNhcHRpb249IiUyNCU3QmluZm9zdGFuZC50ZXh0LmFjaGlldmVtZW50X3Njb3JlJTdEIj4NCiAgICAgICAgICAgICAgICAgIDx2YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJmb250X2ZhY2UiIHZhbHVlPSJWb2x0ZXIgQm9sZCIgdHlwZT0iU3RyaW5nIi8+DQogICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJ0ZXh0X2NvbG9yIiB2YWx1ZT0iMHhmZmZmZmYiIHR5cGU9ImhleCIvPg0KICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0ibW91c2Vfd2hlZWxfZW5hYmxlZCIgdmFsdWU9ImZhbHNlIiB0eXBlPSJCb29sZWFuIi8+DQogICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJzaGFycG5lc3MiIHZhbHVlPSIwIiB0eXBlPSJOdW1iZXIiLz4NCiAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9InRoaWNrbmVzcyIgdmFsdWU9IjAiIHR5cGU9Ik51bWJlciIvPg0KICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0id29yZF93cmFwIiB2YWx1ZT0idHJ1ZSIgdHlwZT0iQm9vbGVhbiIvPg0KICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0ia2VybmluZyIgdmFsdWU9ImZhbHNlIiB0eXBlPSJCb29sZWFuIi8+DQogICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJzcGFjaW5nIiB2YWx1ZT0iMCIgdHlwZT0iTnVtYmVyIi8+DQogICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJsZWFkaW5nIiB2YWx1ZT0iMCIgdHlwZT0iTnVtYmVyIi8+DQogICAgICAgICAgICAgICAgICA8L3ZhcmlhYmxlcz4NCiAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgPHRleHQgdmlzaWJsZT0iZmFsc2UiIHg9IjAiIHk9IjI0MCIgd2lkdGg9IjE3MCIgaGVpZ2h0PSIxNSIgcGFyYW1zPSIxNiIgc3R5bGU9IjAiIG5hbWU9InNjb3JlX3ZhbHVlIj4NCiAgICAgICAgICAgICAgICAgIDx2YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJmb250X2ZhY2UiIHZhbHVlPSJWb2x0ZXIgQm9sZCIgdHlwZT0iU3RyaW5nIi8+DQogICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJ0ZXh0X2NvbG9yIiB2YWx1ZT0iMHhmZmZmZmYiIHR5cGU9ImhleCIvPg0KICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0ibW91c2Vfd2hlZWxfZW5hYmxlZCIgdmFsdWU9ImZhbHNlIiB0eXBlPSJCb29sZWFuIi8+DQogICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJzaGFycG5lc3MiIHZhbHVlPSIwIiB0eXBlPSJOdW1iZXIiLz4NCiAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9InRoaWNrbmVzcyIgdmFsdWU9IjAiIHR5cGU9Ik51bWJlciIvPg0KICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0id29yZF93cmFwIiB2YWx1ZT0idHJ1ZSIgdHlwZT0iQm9vbGVhbiIvPg0KICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0ia2VybmluZyIgdmFsdWU9ImZhbHNlIiB0eXBlPSJCb29sZWFuIi8+DQogICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJzcGFjaW5nIiB2YWx1ZT0iMCIgdHlwZT0iTnVtYmVyIi8+DQogICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJsZWFkaW5nIiB2YWx1ZT0iMCIgdHlwZT0iTnVtYmVyIi8+DQogICAgICAgICAgICAgICAgICA8L3ZhcmlhYmxlcz4NCiAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgPGNvbnRhaW5lciB4PSIwIiB5PSIyNTgiIHdpZHRoPSIxNzAiIGhlaWdodD0iMSIgcGFyYW1zPSIxNiIgc3R5bGU9IjAiIG5hbWU9ImhhbmRpdGVtX3NwYWNlciIgY29sb3I9IjB4ZmZmZjMzMzMzMyIgYmFja2dyb3VuZD0idHJ1ZSIvPg0KICAgICAgICAgICAgICAgIDx0ZXh0IHg9IjAiIHk9IjI2MiIgd2lkdGg9IjE3MCIgaGVpZ2h0PSIxNyIgcGFyYW1zPSIxNiIgc3R5bGU9IjAiIG5hbWU9ImhhbmRpdGVtX3R4dCIgY2FwdGlvbj0iJTI0JTdCaW5mb3N0YW5kLnRleHQuaGFuZGl0ZW0lN0QiPg0KICAgICAgICAgICAgICAgICAgPHZhcmlhYmxlcz4NCiAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9InRleHRfY29sb3IiIHZhbHVlPSIweGZmZmZmZiIgdHlwZT0iaGV4Ii8+DQogICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJtb3VzZV93aGVlbF9lbmFibGVkIiB2YWx1ZT0iZmFsc2UiIHR5cGU9IkJvb2xlYW4iLz4NCiAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9InNoYXJwbmVzcyIgdmFsdWU9IjAiIHR5cGU9Ik51bWJlciIvPg0KICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0idGhpY2tuZXNzIiB2YWx1ZT0iMCIgdHlwZT0iTnVtYmVyIi8+DQogICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJ3b3JkX3dyYXAiIHZhbHVlPSJ0cnVlIiB0eXBlPSJCb29sZWFuIi8+DQogICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJrZXJuaW5nIiB2YWx1ZT0iZmFsc2UiIHR5cGU9IkJvb2xlYW4iLz4NCiAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9InNwYWNpbmciIHZhbHVlPSIwIiB0eXBlPSJOdW1iZXIiLz4NCiAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9ImxlYWRpbmciIHZhbHVlPSIwIiB0eXBlPSJOdW1iZXIiLz4NCiAgICAgICAgICAgICAgICAgIDwvdmFyaWFibGVzPg0KICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICA8Y29udGFpbmVyIHg9IjAiIHk9IjI4MiIgd2lkdGg9IjE3MCIgaGVpZ2h0PSIxIiBwYXJhbXM9IjE2IiBzdHlsZT0iMCIgbmFtZT0idGFnc19zcGFjZXIiIGNvbG9yPSIweGZmZmYzMzMzMzMiIGJhY2tncm91bmQ9InRydWUiLz4NCgkJCQk8Y29udGFpbmVyIHg9IjAiIHk9IjI4NiIgd2lkdGg9IjE3MCIgaGVpZ2h0PSIzMCIgcGFyYW1zPSIxNiIgc3R5bGU9IjAiIG5hbWU9InRhZ3NfY29udGFpbmVyIi8+DQogICAgICAgICAgICAgICAgPGNvbnRhaW5lciB4PSIwIiB5PSIyODciIHdpZHRoPSIxNzAiIGhlaWdodD0iMSIgcGFyYW1zPSIxNiIgc3R5bGU9IjAiIG5hbWU9InRhZ3Nfc3BhY2VyIiBjb2xvcj0iMHhmZmZmMzMzMzMzIiBiYWNrZ3JvdW5kPSJ0cnVlIi8+DQoJCQkJPGl0ZW1saXN0X3ZlcnRpY2FsIHg9IjAiIHk9IjI5MSIgd2lkdGg9IjE3MCIgaGVpZ2h0PSI1NSIgcGFyYW1zPSIxNiIgc3R5bGU9IjAiIG5hbWU9InJlbGF0aW9uc2hpcF9zdGF0dXNfY29udGFpbmVyIj4NCiAgICAgICAgICAgICAgICAgIDxjaGlsZHJlbj4NCiAgICAgICAgICAgICAgICAgICAgPGl0ZW1saXN0X2hvcml6b250YWwgeD0iMCIgeT0iMCIgd2lkdGg9IjE3MiIgaGVpZ2h0PSIxNiIgcGFyYW1zPSIxNiIgc3R5bGU9IjEwMCIgbmFtZT0icmVsYXRpb25zaGlwX2hlYXJ0Ij4NCiAgICAgICAgICAgICAgICAgICAgICA8Y2hpbGRyZW4+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGljX2JpdG1hcCB4PSIwIiB5PSIwIiB3aWR0aD0iMTciIGhlaWdodD0iMTQiIHBhcmFtcz0iMTYiIHN0eWxlPSIxMDAiPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8dmFyaWFibGVzPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJhc3NldF91cmkiIHZhbHVlPSJyZWxhdGlvbnNoaXBfc3RhdHVzX2hlYXJ0IiB0eXBlPSJTdHJpbmciLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0ic3RyZXRjaGVkX3giIHZhbHVlPSJmYWxzZSIgdHlwZT0iQm9vbGVhbiIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJzdHJldGNoZWRfeSIgdmFsdWU9ImZhbHNlIiB0eXBlPSJCb29sZWFuIi8+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDwvdmFyaWFibGVzPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9zdGF0aWNfYml0bWFwPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGxpbmsgeD0iMTciIHk9IjAiIHdpZHRoPSI0OCIgaGVpZ2h0PSIxMyIgcGFyYW1zPSIxIiBzdHlsZT0iMTAwIiBuYW1lPSJoZWFydF9yYW5kb211c2VybmFtZSIgY2FwdGlvbj0idXNlciUyMFBIIiB0cmVzaG9sZD0iMCI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDx2YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9ImF1dG9fc2l6ZSIgdmFsdWU9ImxlZnQiIHR5cGU9IlN0cmluZyIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJ0ZXh0X2NvbG9yIiB2YWx1ZT0iMHhmZmZmZmYiIHR5cGU9ImhleCIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJ0ZXh0X3N0eWxlIiB2YWx1ZT0iYm9sZCIgdHlwZT0iU3RyaW5nIi8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9Im1vdXNlX3doZWVsX2VuYWJsZWQiIHZhbHVlPSJmYWxzZSIgdHlwZT0iQm9vbGVhbiIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJzaGFycG5lc3MiIHZhbHVlPSIwIiB0eXBlPSJOdW1iZXIiLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0idGhpY2tuZXNzIiB2YWx1ZT0iMCIgdHlwZT0iTnVtYmVyIi8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9InVuZGVybGluZSIgdmFsdWU9InRydWUiIHR5cGU9IkJvb2xlYW4iLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0ia2VybmluZyIgdmFsdWU9ImZhbHNlIiB0eXBlPSJCb29sZWFuIi8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9InNwYWNpbmciIHZhbHVlPSIwIiB0eXBlPSJOdW1iZXIiLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0ibGVhZGluZyIgdmFsdWU9IjAiIHR5cGU9Ik51bWJlciIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8L3ZhcmlhYmxlcz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvbGluaz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCB4PSI2NSIgeT0iMCIgd2lkdGg9IjE2OCIgaGVpZ2h0PSIxMyIgcGFyYW1zPSIxNiIgc3R5bGU9IjEwMCIgbmFtZT0iaGVhcnRfb3RoZXJzIiBjYXB0aW9uPSIlMjQlN0JpbmZvc3RhbmQucmVsc3RhdHVzLmhlYXJ0Lm90aGVycyU3RCI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDx2YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9InRleHRfc3R5bGUiIHZhbHVlPSJyZWd1bGFyIiB0eXBlPSJTdHJpbmciLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0idGV4dF9jb2xvciIgdmFsdWU9IjB4ZmZmZmZmIiB0eXBlPSJoZXgiLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC92YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPg0KICAgICAgICAgICAgICAgICAgICAgIDwvY2hpbGRyZW4+DQogICAgICAgICAgICAgICAgICAgICAgPHZhcmlhYmxlcz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJzY2FsZV90b19maXRfaXRlbXMiIHZhbHVlPSJ0cnVlIiB0eXBlPSJCb29sZWFuIi8+DQogICAgICAgICAgICAgICAgICAgICAgPC92YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgICAgIDwvaXRlbWxpc3RfaG9yaXpvbnRhbD4NCiAgICAgICAgICAgICAgICAgICAgPGl0ZW1saXN0X2hvcml6b250YWwgeD0iMCIgeT0iMTkiIHdpZHRoPSIxNzIiIGhlaWdodD0iMTYiIHBhcmFtcz0iMTYiIHN0eWxlPSIxMDAiIG5hbWU9InJlbGF0aW9uc2hpcF9zbWlsZSI+DQogICAgICAgICAgICAgICAgICAgICAgPGNoaWxkcmVuPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRpY19iaXRtYXAgeD0iMCIgeT0iMCIgd2lkdGg9IjE3IiBoZWlnaHQ9IjE0IiBwYXJhbXM9IjE2IiBzdHlsZT0iMTAwIj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHZhcmlhYmxlcz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0iYXNzZXRfdXJpIiB2YWx1ZT0icmVsYXRpb25zaGlwX3N0YXR1c19zbWlsZSIgdHlwZT0iU3RyaW5nIi8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9InN0cmV0Y2hlZF94IiB2YWx1ZT0iZmFsc2UiIHR5cGU9IkJvb2xlYW4iLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0ic3RyZXRjaGVkX3kiIHZhbHVlPSJmYWxzZSIgdHlwZT0iQm9vbGVhbiIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8L3ZhcmlhYmxlcz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvc3RhdGljX2JpdG1hcD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxsaW5rIHg9IjE3IiB5PSIwIiB3aWR0aD0iNDgiIGhlaWdodD0iMTMiIHBhcmFtcz0iMSIgc3R5bGU9IjEwMCIgbmFtZT0ic21pbGVfcmFuZG9tdXNlcm5hbWUiIGNhcHRpb249InVzZXIlMjBQSCIgdHJlc2hvbGQ9IjAiPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8dmFyaWFibGVzPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJhdXRvX3NpemUiIHZhbHVlPSJsZWZ0IiB0eXBlPSJTdHJpbmciLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0idGV4dF9jb2xvciIgdmFsdWU9IjB4ZmZmZmZmIiB0eXBlPSJoZXgiLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0idGV4dF9zdHlsZSIgdmFsdWU9ImJvbGQiIHR5cGU9IlN0cmluZyIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJtb3VzZV93aGVlbF9lbmFibGVkIiB2YWx1ZT0iZmFsc2UiIHR5cGU9IkJvb2xlYW4iLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0ic2hhcnBuZXNzIiB2YWx1ZT0iMCIgdHlwZT0iTnVtYmVyIi8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9InRoaWNrbmVzcyIgdmFsdWU9IjAiIHR5cGU9Ik51bWJlciIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJ1bmRlcmxpbmUiIHZhbHVlPSJ0cnVlIiB0eXBlPSJCb29sZWFuIi8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9Imtlcm5pbmciIHZhbHVlPSJmYWxzZSIgdHlwZT0iQm9vbGVhbiIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJzcGFjaW5nIiB2YWx1ZT0iMCIgdHlwZT0iTnVtYmVyIi8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9ImxlYWRpbmciIHZhbHVlPSIwIiB0eXBlPSJOdW1iZXIiLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC92YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2xpbms+DQogICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgeD0iNjUiIHk9IjAiIHdpZHRoPSIxNjQiIGhlaWdodD0iMTMiIHBhcmFtcz0iMTYiIHN0eWxlPSIxMDAiIG5hbWU9InNtaWxlX290aGVycyIgY2FwdGlvbj0iJTI0JTdCaW5mb3N0YW5kLnJlbHN0YXR1cy5zbWlsZS5vdGhlcnMlN0QiPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8dmFyaWFibGVzPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJ0ZXh0X3N0eWxlIiB2YWx1ZT0icmVndWxhciIgdHlwZT0iU3RyaW5nIi8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9InRleHRfY29sb3IiIHZhbHVlPSIweGZmZmZmZiIgdHlwZT0iaGV4Ii8+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDwvdmFyaWFibGVzPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9sYWJlbD4NCiAgICAgICAgICAgICAgICAgICAgICA8L2NoaWxkcmVuPg0KICAgICAgICAgICAgICAgICAgICAgIDx2YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0ic2NhbGVfdG9fZml0X2l0ZW1zIiB2YWx1ZT0idHJ1ZSIgdHlwZT0iQm9vbGVhbiIvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvdmFyaWFibGVzPg0KICAgICAgICAgICAgICAgICAgICA8L2l0ZW1saXN0X2hvcml6b250YWw+DQogICAgICAgICAgICAgICAgICAgIDxpdGVtbGlzdF9ob3Jpem9udGFsIHg9IjAiIHk9IjM4IiB3aWR0aD0iMTcyIiBoZWlnaHQ9IjE2IiBwYXJhbXM9IjE2IiBzdHlsZT0iMTAwIiBuYW1lPSJyZWxhdGlvbnNoaXBfYm9iYmEiPg0KICAgICAgICAgICAgICAgICAgICAgIDxjaGlsZHJlbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0aWNfYml0bWFwIHg9IjAiIHk9IjAiIHdpZHRoPSIxNyIgaGVpZ2h0PSIxNCIgcGFyYW1zPSIxNiIgc3R5bGU9IjEwMCI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDx2YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9ImFzc2V0X3VyaSIgdmFsdWU9InJlbGF0aW9uc2hpcF9zdGF0dXNfYm9iYmEiIHR5cGU9IlN0cmluZyIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJzdHJldGNoZWRfeCIgdmFsdWU9ImZhbHNlIiB0eXBlPSJCb29sZWFuIi8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9InN0cmV0Y2hlZF95IiB2YWx1ZT0iZmFsc2UiIHR5cGU9IkJvb2xlYW4iLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC92YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgICAgICAgICA8L3N0YXRpY19iaXRtYXA+DQogICAgICAgICAgICAgICAgICAgICAgICA8bGluayB4PSIxNyIgeT0iMCIgd2lkdGg9IjQ4IiBoZWlnaHQ9IjEzIiBwYXJhbXM9IjEiIHN0eWxlPSIxMDAiIG5hbWU9ImJvYmJhX3JhbmRvbXVzZXJuYW1lIiBjYXB0aW9uPSJ1c2VyJTIwUEgiIHRyZXNob2xkPSIwIj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHZhcmlhYmxlcz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0iYXV0b19zaXplIiB2YWx1ZT0ibGVmdCIgdHlwZT0iU3RyaW5nIi8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9InRleHRfY29sb3IiIHZhbHVlPSIweGZmZmZmZiIgdHlwZT0iaGV4Ii8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9InRleHRfc3R5bGUiIHZhbHVlPSJib2xkIiB0eXBlPSJTdHJpbmciLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0ibW91c2Vfd2hlZWxfZW5hYmxlZCIgdmFsdWU9ImZhbHNlIiB0eXBlPSJCb29sZWFuIi8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9InNoYXJwbmVzcyIgdmFsdWU9IjAiIHR5cGU9Ik51bWJlciIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJ0aGlja25lc3MiIHZhbHVlPSIwIiB0eXBlPSJOdW1iZXIiLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0idW5kZXJsaW5lIiB2YWx1ZT0idHJ1ZSIgdHlwZT0iQm9vbGVhbiIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJrZXJuaW5nIiB2YWx1ZT0iZmFsc2UiIHR5cGU9IkJvb2xlYW4iLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0ic3BhY2luZyIgdmFsdWU9IjAiIHR5cGU9Ik51bWJlciIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJsZWFkaW5nIiB2YWx1ZT0iMCIgdHlwZT0iTnVtYmVyIi8+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDwvdmFyaWFibGVzPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9saW5rPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIHg9IjY1IiB5PSIwIiB3aWR0aD0iMTcwIiBoZWlnaHQ9IjEzIiBwYXJhbXM9IjE2IiBzdHlsZT0iMTAwIiBuYW1lPSJib2JiYV9vdGhlcnMiIGNhcHRpb249IiUyNCU3QmluZm9zdGFuZC5yZWxzdGF0dXMuYm9iYmEub3RoZXJzJTdEIj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHZhcmlhYmxlcz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dmFyIGtleT0idGV4dF9zdHlsZSIgdmFsdWU9InJlZ3VsYXIiIHR5cGU9IlN0cmluZyIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJ0ZXh0X2NvbG9yIiB2YWx1ZT0iMHhmZmZmZmYiIHR5cGU9ImhleCIvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8L3ZhcmlhYmxlcz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvbGFiZWw+DQogICAgICAgICAgICAgICAgICAgICAgPC9jaGlsZHJlbj4NCiAgICAgICAgICAgICAgICAgICAgICA8dmFyaWFibGVzPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHZhciBrZXk9InNjYWxlX3RvX2ZpdF9pdGVtcyIgdmFsdWU9InRydWUiIHR5cGU9IkJvb2xlYW4iLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3ZhcmlhYmxlcz4NCiAgICAgICAgICAgICAgICAgICAgPC9pdGVtbGlzdF9ob3Jpem9udGFsPg0KICAgICAgICAgICAgICAgICAgPC9jaGlsZHJlbj4NCiAgICAgICAgICAgICAgICAgIDx2YXJpYWJsZXM+DQogICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJzcGFjaW5nIiB2YWx1ZT0iMyIgdHlwZT0iaW50Ii8+DQogICAgICAgICAgICAgICAgICAgIDx2YXIga2V5PSJzY2FsZV90b19maXRfaXRlbXMiIHZhbHVlPSJ0cnVlIiB0eXBlPSJCb29sZWFuIi8+DQogICAgICAgICAgICAgICAgICA8L3ZhcmlhYmxlcz4NCiAgICAgICAgICAgICAgICA8L2l0ZW1saXN0X3ZlcnRpY2FsPg0KICAgICAgICAgICAgICA8L2NoaWxkcmVuPg0KICAgICAgICAgICAgICA8dmFyaWFibGVzPg0KICAgICAgICAgICAgICAgIDx2YXIga2V5PSJzcGFjaW5nIiB2YWx1ZT0iMyIgdHlwZT0iaW50Ii8+DQogICAgICAgICAgICAgICAgPHZhciBrZXk9InNjYWxlX3RvX2ZpdF9pdGVtcyIgdmFsdWU9InRydWUiIHR5cGU9IkJvb2xlYW4iLz4NCiAgICAgICAgICAgICAgICA8dmFyIGtleT0icmVzaXplX29uX2l0ZW1fdXBkYXRlIiB2YWx1ZT0idHJ1ZSIgdHlwZT0iQm9vbGVhbiIvPg0KICAgICAgICAgICAgICA8L3ZhcmlhYmxlcz4NCiAgICAgICAgICAgIDwvaXRlbWxpc3RfdmVydGljYWw+DQogICAgICAgICAgPC9jaGlsZHJlbj4NCiAgICAgICAgPC9ib3JkZXI+DQogICAgICA8L2NoaWxkcmVuPg0KICAgICAgPHZhcmlhYmxlcz4NCiAgICAgICAgPHZhciBrZXk9InNwYWNpbmciIHZhbHVlPSIxMCIgdHlwZT0iaW50Ii8+DQogICAgICA8L3ZhcmlhYmxlcz4NCiAgICA8L2l0ZW1saXN0X3ZlcnRpY2FsPg0KICA8L3dpbmRvdz4NCjwvbGF5b3V0Pg==";
        #endregion

        private static readonly string[] _reservedNames = new[]
        {
            "break", "case", "catch", "class", "continue",
            "default", "do", "dynamic", "each", "else",
            "extends", "false", "final", "finally", "for",
            "function", "get", "if", "implements", "import",
            "in", "include", "native", "null", "override",
            "package", "return", "set", "static", "super",
            "switch", "throw", "true", "try", "use",
            "var", "while", "with"
        };

        private readonly Dictionary<DoABCTag, ABCFile> _abcFileTags;
        private readonly Dictionary<ASClass, MessageItem> _messages;

        public List<ABCFile> ABCFiles { get; }
        public bool IsPostShuffle { get; private set; } = true;

        public SortedDictionary<ushort, MessageItem> InMessages { get; }
        public SortedDictionary<ushort, MessageItem> OutMessages { get; }
        public SortedDictionary<string, List<MessageItem>> Messages { get; }

        private int _revisionIndex;
        public string Revision
        {
            get
            {
                if (ABCFiles.Count >= 3)
                {
                    return ABCFiles.Last().Pool.Strings[_revisionIndex];
                }
                else return "PRODUCTION-000000000000-000000000";
            }
            set
            {
                if (ABCFiles.Count >= 3)
                {
                    ABCFiles.Last().Pool.Strings[_revisionIndex] = value;
                }
            }
        }

        public string Location { get; set; }

        public HGame(string path)
            : this(File.OpenRead(path))
        {
            Location = path;
        }
        public HGame(byte[] data)
            : this(new MemoryStream(data))

        { }
        public HGame(Stream input)
            : this(input, false)
        { }
        public HGame(Stream input, bool leaveOpen)
            : this(new FlashReader(input, leaveOpen))
        { }
        protected HGame(FlashReader input)
            : base(input)
        {
            _abcFileTags = new Dictionary<DoABCTag, ABCFile>();
            _messages = new Dictionary<ASClass, MessageItem>();

            ABCFiles = new List<ABCFile>();
            InMessages = new SortedDictionary<ushort, MessageItem>();
            OutMessages = new SortedDictionary<ushort, MessageItem>();
            Messages = new SortedDictionary<string, List<MessageItem>>();
        }

        public void GenerateMessageHashes()
        {
            FindMessagesReferences();
            foreach (MessageItem message in OutMessages.Values.Concat(InMessages.Values))
            {
                List<MessageItem> group = null;
                if (!Messages.TryGetValue(message.GenerateHash(), out group))
                {
                    group = new List<MessageItem>();
                    Messages.Add(message.Hash, group);
                }
                group.Add(message);
            }
        }

        #region Message Reference Searching
        private void FindMessagesReferences()
        {
            int classRank = 1;
            ABCFile abc = ABCFiles.Last();
            foreach (ASClass @class in abc.Classes)
            {
                ASInstance instance = @class.Instance;
                if (_messages.ContainsKey(@class)) continue;
                if (instance.Flags.HasFlag(ClassFlags.Interface)) continue;

                IEnumerable<ASMethod> methods = (new[] { @class.Constructor, instance.Constructor })
                    .Concat(instance.GetMethods())
                    .Concat(@class.GetMethods());

                int methodRank = 0;
                foreach (ASMethod fromMethod in methods)
                {
                    bool isStatic = (fromMethod.Trait?.IsStatic ?? @class.Constructor == fromMethod);
                    var fromContainer = (isStatic ? (ASContainer)@class : instance);

                    List<MessageReference> refernces = FindMessageReferences(@class, fromContainer, fromMethod);
                    if (refernces.Count > 0)
                    {
                        methodRank++;
                    }
                    foreach (MessageReference reference in refernces)
                    {
                        reference.IsStatic = isStatic;
                        reference.ClassRank = classRank;
                        reference.MethodRank = methodRank;
                        reference.GroupCount = refernces.Count;
                    }
                }
                if (methodRank > 0)
                {
                    classRank++;
                }
            }

            var froms = new Dictionary<ASContainer, List<MessageReference>>();
            foreach (MessageItem incomingMsg in InMessages.Values)
            {
                foreach (MessageReference reference in incomingMsg.References)
                {
                    List<MessageReference> references = null;
                    if (!froms.TryGetValue(reference.FromMethod.Container, out references))
                    {
                        references = new List<MessageReference>();
                        froms.Add(reference.FromMethod.Container, references);
                    }
                    if (!references.Contains(reference))
                    {
                        references.Add(reference);
                    }
                }
            }

            classRank = 1;
            foreach (ASClass @class in abc.Classes)
            {
                ASContainer container = null;
                List<MessageReference> references = null;
                if (froms.TryGetValue(@class, out references))
                {
                    container = @class;
                }
                else if (froms.TryGetValue(@class.Instance, out references))
                {
                    container = @class.Instance;
                }
                if (container != null)
                {
                    var methodReferenceGroups = new Dictionary<ASMethod, List<MessageReference>>();
                    foreach (MessageReference reference in references)
                    {
                        reference.FromClass = @class;
                        reference.InstructionRank = -1;
                        reference.ClassRank = classRank;
                        reference.IsStatic = container.IsStatic;
                        reference.GroupCount = references.Count;

                        List<MessageReference> methodReferences = null;
                        if (!methodReferenceGroups.TryGetValue(reference.FromMethod, out methodReferences))
                        {
                            methodReferences = new List<MessageReference>();
                            methodReferenceGroups.Add(reference.FromMethod, methodReferences);
                        }
                        methodReferences.Add(reference);
                    }

                    int methodRank = 1;
                    foreach (ASMethod method in container.GetMethods())
                    {
                        List<MessageReference> methodReferences = null;
                        if (methodReferenceGroups.TryGetValue(method, out methodReferences))
                        {
                            foreach (MessageReference reference in methodReferences)
                            {
                                reference.MethodRank = methodRank;
                            }
                            methodRank++;
                        }
                    }
                    classRank++;
                }
            }
        }
        private List<MessageReference> FindMessageReferences(ASClass fromClass, ASContainer fromContainer, ASMethod fromMethod)
        {
            int instructionRank = 0;
            ABCFile abc = fromMethod.GetABC();

            var nameStack = new Stack<ASMultiname>();
            var references = new List<MessageReference>();

            ASContainer container = null;
            ASCode code = fromMethod.Body.ParseCode();
            for (int i = 0; i < code.Count; i++)
            {
                int extraNamePopCount = 0;
                ASInstruction instruction = code[i];
                switch (instruction.OP)
                {
                    default: continue;
                    case OPCode.NewFunction:
                    {
                        var newFunction = (NewFunctionIns)instruction;
                        references.AddRange(FindMessageReferences(fromClass, fromContainer, newFunction.Method));
                        continue;
                    }
                    case OPCode.GetProperty:
                    {
                        var getProperty = (GetPropertyIns)instruction;
                        nameStack.Push(getProperty.PropertyName);
                        continue;
                    }
                    case OPCode.GetLex:
                    {
                        var getLex = (GetLexIns)instruction;
                        container = abc.GetClass(getLex.TypeName.Name);
                        continue;
                    }
                    case OPCode.GetLocal_0:
                    {
                        container = fromContainer;
                        continue;
                    }
                    case OPCode.ConstructProp:
                    {
                        var constructProp = (ConstructPropIns)instruction;

                        extraNamePopCount = constructProp.ArgCount;
                        nameStack.Push(constructProp.PropertyName);
                        break;
                    }
                }

                ASMultiname messageQName = nameStack.Pop();
                if (string.IsNullOrWhiteSpace(messageQName.Name)) continue;

                ASClass messageClass = abc.GetClass(messageQName.Name);
                if (messageClass == null) continue;

                MessageItem message = null;
                if (!_messages.TryGetValue(messageClass, out message)) continue;
                if (message.HasMethodReference(fromMethod)) continue;

                var reference = new MessageReference();
                message.References.Add(reference);

                if (message.IsOutgoing)
                {
                    reference.FromClass = fromClass;
                    reference.FromMethod = fromMethod;
                    reference.InstructionRank = ++instructionRank;
                    reference.IsAnonymous = (!fromMethod.IsConstructor && fromMethod.Trait == null);

                    references.Add(reference);
                }
                else
                {
                    ASMultiname methodName = nameStack.Pop();
                    ASMethod callbackMethod = fromContainer.GetMethod(methodName.Name);
                    if (callbackMethod == null)
                    {
                        callbackMethod = container.GetMethod(methodName.Name);
                        if (callbackMethod == null)
                        {
                            ASMultiname slotName = nameStack.Pop();

                            ASTrait hostTrait = container.GetTraits(TraitKind.Slot)
                                .FirstOrDefault(st => st.QName == slotName);

                            container = abc.GetInstance(hostTrait.Type.Name);
                            callbackMethod = container.GetMethod(methodName.Name);
                        }
                    }
                    reference.FromMethod = callbackMethod;
                }
            }
            return references;
        }
        #endregion

        public ushort[] GetMessageIds(string hash)
        {
            List<MessageItem> messages = null;
            if (Messages.TryGetValue(hash, out messages))
            {
                return messages.Select(m => m.Id).ToArray();
            }
            return null;
        }

        private void LoadMessages()
        {
            ABCFile abc = ABCFiles.Last();
            ASClass habboMessagesClass = abc.GetClass("HabboMessages");
            if (habboMessagesClass == null)
            {
                IsPostShuffle = false;
                foreach (ASClass @class in abc.Classes)
                {
                    if (@class.Traits.Count != 2 || @class.Traits[0].Type?.Name != "Map" || @class.Traits[1].Type?.Name != "Map") continue;
                    if (@class.Instance.Traits.Count != 2) continue;

                    habboMessagesClass = @class;
                    break;
                }
                if (habboMessagesClass == null) return;
            }

            ASCode code = habboMessagesClass.Constructor.Body.ParseCode();
            int inMapTypeIndex = habboMessagesClass.Traits[0].QNameIndex;
            int outMapTypeIndex = habboMessagesClass.Traits[1].QNameIndex;

            ASInstruction[] instructions = code
                .Where(i => i.OP == OPCode.GetLex ||
                            i.OP == OPCode.PushShort ||
                            i.OP == OPCode.PushByte)
                .ToArray();

            for (int i = 0; i < instructions.Length; i += 3)
            {
                var getLexInst = (instructions[i + 0] as GetLexIns);
                bool isOutgoing = (getLexInst.TypeNameIndex == outMapTypeIndex);

                var primitive = (instructions[i + 1] as Primitive);
                ushort id = Convert.ToUInt16(primitive.Value);

                getLexInst = (instructions[i + 2] as GetLexIns);
                ASClass messageClass = abc.GetClass(getLexInst.TypeName.Name);

                var message = new MessageItem(messageClass, isOutgoing, id);
                (isOutgoing ? OutMessages : InMessages).Add(id, message);

                if (_messages.ContainsKey(messageClass))
                {
                    _messages[messageClass].SharedIds.Add(id);
                }
                else _messages.Add(messageClass, message);

                if (id == 4000 && isOutgoing)
                {
                    ASInstance messageInstance = messageClass.Instance;
                    ASMethod toArrayMethod = messageInstance.GetMethod(null, "Array", 0);

                    ASCode toArrayCode = toArrayMethod.Body.ParseCode();
                    int index = toArrayCode.IndexOf(OPCode.PushString);

                    if (index != -1)
                    {
                        var pushStringIns = (PushStringIns)toArrayCode[index];
                        _revisionIndex = pushStringIns.ValueIndex;
                    }
                }
            }
        }
        private void SimplifySendCode(ABCFile abc, ASCode sendCode)
        {
            bool isTrimming = true;
            for (int i = 0; i < sendCode.Count; i++)
            {
                ASInstruction instruction = sendCode[i];
                if (!isTrimming && Local.IsValid(instruction.OP))
                {
                    var local = (Local)instruction;
                    int newRegister = (local.Register - 1);
                    if (newRegister < 1) continue;

                    ASInstruction replacement = null;
                    if (Local.IsGetLocal(local.OP))
                    {
                        replacement = new GetLocalIns(newRegister);
                    }
                    else if (Local.IsSetLocal(local.OP))
                    {
                        replacement = new SetLocalIns(newRegister);
                    }
                    sendCode[i] = replacement;
                }
                else if (isTrimming)
                {
                    if (instruction.OP != OPCode.CallProperty) continue;

                    var callProperty = (CallPropertyIns)instruction;
                    if (callProperty.PropertyName.Name != "encode") continue;

                    sendCode.RemoveRange(0, i - 4);
                    int idNameIndex = abc.Pool.AddConstant("id");
                    int valuesNameIndex = abc.Pool.AddConstant("values");

                    i = 0;
                    isTrimming = false;
                    sendCode.InsertRange(0, new ASInstruction[]
                    {
                        new GetLocal0Ins(),
                        new PushScopeIns(),
                        new DebugIns(abc, idNameIndex, 1, 0),
                        new DebugIns(abc, valuesNameIndex, 1, 1)
                    });
                }
            }
        }

        public override void Disassemble(Action<TagItem> callback)
        {
            base.Disassemble(callback);
            LoadMessages();
        }
        protected override void WriteTag(TagItem tag, FlashWriter output)
        {
            if (tag.Kind == TagKind.DoABC)
            {
                var doABCTag = (DoABCTag)tag;
                doABCTag.ABCData = _abcFileTags[doABCTag].ToArray();
            }
            base.WriteTag(tag, output);
        }
        protected override TagItem ReadTag(HeaderRecord header, FlashReader input)
        {
            TagItem tag = base.ReadTag(header, input);
            if (tag.Kind == TagKind.DoABC)
            {
                var doABCTag = (DoABCTag)tag;
                var abcFile = new ABCFile(doABCTag.ABCData);

                _abcFileTags[doABCTag] = abcFile;
                ABCFiles.Add(abcFile);
            }
            return tag;
        }

        public static bool IsValidIdentifier(string value, bool invalidOnSanitized = false)
        {
            value = value.ToLower();
            if (invalidOnSanitized &&
                (value.StartsWith("class_") ||
                value.StartsWith("iinterface_") ||
                value.StartsWith("namespace_") ||
                value.StartsWith("method_") ||
                value.StartsWith("constant_") ||
                value.StartsWith("slot_") ||
                value.StartsWith("param")))
            {
                return false;
            }

            return (!value.Contains("_-") &&
                !_reservedNames.Contains(value.Trim()));
        }
    }

    public class HashWriter : BinaryWriter
    {
        private readonly SortedDictionary<int, int> _ints;
        private readonly SortedDictionary<bool, int> _bools;
        private readonly SortedDictionary<byte, int> _bytes;
        private readonly SortedDictionary<string, int> _strings;

        public bool IsSorting { get; set; }

        public HashWriter(bool isSorting)
            : base(new MemoryStream())
        {
            _ints = new SortedDictionary<int, int>();
            _bools = new SortedDictionary<bool, int>();
            _bytes = new SortedDictionary<byte, int>();
            _strings = new SortedDictionary<string, int>();

            IsSorting = isSorting;
        }

        public override void Write(int value)
        {
            WriteOrSort(_ints, base.Write, value);
        }
        public override void Write(bool value)
        {
            WriteOrSort(_bools, base.Write, value);
        }
        public override void Write(byte value)
        {
            WriteOrSort(_bytes, base.Write, value);
        }
        public override void Write(string value)
        {
            WriteOrSort(_strings, base.Write, value);
        }

        public void Write(ASTrait trait)
        {
            Write(trait.Id);
            Write(trait.QName);
            Write(trait.IsStatic);
            Write((byte)trait.Kind);
            Write((byte)trait.Attributes);
            switch (trait.Kind)
            {
                case TraitKind.Slot:
                case TraitKind.Constant:
                {
                    Write(trait.Type);
                    if (trait.Value != null)
                    {
                        Write(trait.ValueKind, trait.Value);
                    }
                    break;
                }
                case TraitKind.Method:
                case TraitKind.Getter:
                case TraitKind.Setter:
                {
                    Write(trait.Method);
                    break;
                }
            }
        }
        public void Write(ASMethod method)
        {
            Write(method.IsConstructor);
            if (!method.IsConstructor)
            {
                Write(method.ReturnType);
            }
            Write(method.Parameters.Count);
            foreach (ASParameter parameter in method.Parameters)
            {
                Write(parameter.Type);
                if (!string.IsNullOrWhiteSpace(parameter.Name) &&
                    HGame.IsValidIdentifier(parameter.Name, true))
                {
                    Write(parameter.Name);
                }
                Write(parameter.IsOptional);
                if (parameter.IsOptional)
                {
                    Write((byte)parameter.ValueKind);
                    Write(parameter.ValueKind, parameter.Value);
                }
            }
            ASCode code = method.Body.ParseCode();
            foreach (OPCode op in code.GetOPGroups().Keys)
            {
                if (op != OPCode.GetLex
                    && op != OPCode.GetProperty
                    && op != OPCode.CallProperty) continue;

                Write((byte)op);
            }
        }
        public void Write(ASMultiname multiname)
        {
            if (multiname?.Kind == MultinameKind.TypeName)
            {
                Write(multiname.QName);
                Write(multiname.TypeIndices.Count);
                foreach (ASMultiname type in multiname.GetTypes())
                {
                    Write(type);
                }
            }
            else if (multiname == null ||
                HGame.IsValidIdentifier(multiname.Name, true))
            {
                Write(multiname?.Name ?? "*");
            }
        }
        public void Write(ConstantKind kind, object value)
        {
            Write((byte)kind);
            switch (kind)
            {
                case ConstantKind.Double:
                Write((double)value);
                break;
                case ConstantKind.Integer:
                Write((int)value);
                break;
                case ConstantKind.UInteger:
                Write((uint)value);
                break;
                case ConstantKind.String:
                Write((string)value);
                break;
                case ConstantKind.Null:
                Write("null");
                break;
                case ConstantKind.True:
                Write(true);
                break;
                case ConstantKind.False:
                Write(false);
                break;
            }
        }
        public void Write(ASContainer container, bool includeTraits)
        {
            Write(container.IsStatic);
            if (includeTraits)
            {
                Write(container.Traits.Count);
                container.Traits.ForEach(t => Write(t));
            }
        }

        public override void Flush()
        {
            WriteSorted(_ints, base.Write);
            WriteSorted(_bools, base.Write);
            WriteSorted(_bytes, base.Write);
            WriteSorted(_strings, base.Write);
        }
        public string GenerateMD5Hash()
        {
            Flush();
            using (var md5 = MD5.Create())
            {
                long curPos = BaseStream.Position;
                BaseStream.Position = 0;

                byte[] hashData = md5.ComputeHash(BaseStream);
                string hashAsHex = (BitConverter.ToString(hashData));

                BaseStream.Position = curPos;
                return hashAsHex.Replace("-", string.Empty).ToLower();
            }
        }

        private void WriteSorted<T>(IDictionary<T, int> storage, Action<T> writer)
        {
            foreach (KeyValuePair<T, int> storedPair in storage)
            {
                writer(storedPair.Key);
                base.Write(storedPair.Value);
            }
        }
        private void WriteOrSort<T>(IDictionary<T, int> storage, Action<T> writer, T value)
        {
            if (IsSorting)
            {
                if (storage.ContainsKey(value))
                {
                    storage[value]++;
                }
                else storage.Add(value, 1);
            }
            else writer(value);
        }
    }

    public class MessageItem
    {
        public ushort Id { get; set; }
        public string Hash { get; set; }
        public bool IsOutgoing { get; set; }

        public ASClass Class { get; }
        public ASClass Parser { get; }
        public string[] Structure { get; }
        public List<ushort> SharedIds { get; }
        public List<MessageReference> References { get; }

        public MessageItem(ASClass messageClass, bool isOutgoing, ushort id)
        {
            Id = id;
            Class = messageClass;
            IsOutgoing = isOutgoing;

            SharedIds = new List<ushort>();
            References = new List<MessageReference>();

            if (!IsOutgoing)
            {
                Parser = GetMessageParser();
                if (Parser != null)
                {
                    Structure = GetIncomingStructure(Parser);
                }
            }
            else
            {
                Structure = GetOutgoingStructure(Class);
            }
        }

        public string GenerateHash()
        {
            if (!string.IsNullOrWhiteSpace(Hash))
            {
                return Hash;
            }

            using (var output = new HashWriter(false))
            {
                output.Write(IsOutgoing);
                if (!HGame.IsValidIdentifier(Class.QName.Name, true))
                {
                    output.Write(Class.Instance, true);
                    output.Write(Class.Instance.Constructor);

                    output.Write(References.Count);
                    foreach (MessageReference reference in References)
                    {
                        output.Write(reference.IsStatic);
                        output.Write(reference.IsAnonymous);

                        output.Write(reference.MethodRank);
                        output.Write(reference.InstructionRank);

                        output.Write(reference.FromMethod);

                        output.Write(reference.FromClass.Constructor);
                        output.Write(reference.FromClass.Instance.Constructor);
                    }
                    if (!IsOutgoing && Parser != null)
                    {
                        output.Write(Parser.Instance, true);
                    }
                }
                else output.Write(Class.QName.Name);
                return (Hash = output.GenerateMD5Hash());
            }
        }
        public bool HasMethodReference(ASMethod method)
        {
            return References.Any(r => r.FromMethod == method);
        }

        public int GetMatchDeviation(MessageItem message)
        {
            if (Class.QName.Name == message.Class.QName.Name) return 0;

            int cClassRankTotal = 0;
            foreach (MessageReference reference in References)
            {
                cClassRankTotal += reference.ClassRank;
            }

            int pClassRankTotal = 0;
            foreach (MessageReference reference in message.References)
            {
                pClassRankTotal += reference.ClassRank;
            }

            return Math.Abs(cClassRankTotal - pClassRankTotal);
        }
        public MessageItem GetClosestMatch(IEnumerable<MessageItem> messages)
        {
            MessageItem closestMatch = null;
            int lowestDeviation = int.MaxValue;
            foreach (MessageItem message in messages)
            {
                int deviation = GetMatchDeviation(message);
                if (deviation == 0) return message;

                if (deviation < lowestDeviation)
                {
                    closestMatch = message;
                    lowestDeviation = deviation;
                }
            }
            return closestMatch;
        }

        private ASClass GetMessageParser()
        {
            ABCFile abc = Class.GetABC();
            ASInstance instance = Class.Instance;

            ASInstance superInstance = abc.GetInstance(instance.Super.Name);
            if (superInstance == null) superInstance = instance;

            ASMethod parserGetterMethod = superInstance.GetGetter("parser")?.Method;
            if (parserGetterMethod == null) return null;

            IEnumerable<ASMethod> methods = instance.GetMethods();
            foreach (ASMethod method in methods.Concat(new[] { instance.Constructor }))
            {
                ASCode code = method.Body.ParseCode();
                foreach (ASInstruction instruction in code)
                {
                    ASMultiname multiname = null;
                    if (instruction.OP == OPCode.FindPropStrict)
                    {
                        var findPropStrictIns = (FindPropStrictIns)instruction;
                        multiname = findPropStrictIns.PropertyName;
                    }
                    else if (instruction.OP == OPCode.GetLex)
                    {
                        var getLexIns = (GetLexIns)instruction;
                        multiname = getLexIns.TypeName;
                    }
                    else continue;

                    foreach (ASClass refClass in abc.GetClasses(multiname.Name))
                    {
                        ASInstance refInstance = refClass.Instance;
                        if (refInstance.ContainsInterface(parserGetterMethod.ReturnType.Name))
                        {
                            return refClass;
                        }
                    }
                }
            }
            return null;
        }

        #region Structure Extraction
        private string[] GetIncomingStructure(ASClass @class)
        {
            ASMethod parseMethod = @class.Instance.GetMethod("parse", "Boolean", 1);
            return GetIncomingStructure(@class.Instance, parseMethod);
        }
        private string[] GetIncomingStructure(ASInstance instance, ASMethod method)
        {
            if (method.Body.Exceptions.Count > 0) return null;

            ASCode code = method.Body.ParseCode();
            if (code.JumpExits.Count > 0 || code.SwitchExits.Count > 0) return null;

            ABCFile abc = method.GetABC();
            var structure = new List<string>();
            for (int i = 0; i < code.Count; i++)
            {
                ASInstruction instruction = code[i];
                if (instruction.OP != OPCode.GetLocal_1) continue;

                ASInstruction next = code[++i];
                switch (next.OP)
                {
                    case OPCode.CallProperty:
                    {
                        var callProperty = (CallPropertyIns)next;
                        if (callProperty.ArgCount > 0)
                        {
                            ASMultiname propertyName = null;
                            ASInstruction previous = code[i - 2];

                            switch (previous.OP)
                            {
                                case OPCode.GetLex:
                                {
                                    var getLex = (GetLexIns)previous;
                                    propertyName = getLex.TypeName;
                                    break;
                                }

                                case OPCode.ConstructProp:
                                {
                                    var constructProp = (ConstructPropIns)previous;
                                    propertyName = constructProp.PropertyName;
                                    break;
                                }

                                case OPCode.GetLocal_0:
                                {
                                    propertyName = instance.QName;
                                    break;
                                }
                            }

                            ASInstance innerInstance = abc.GetInstance(propertyName.Name);
                            ASMethod innerMethod = innerInstance.GetMethods(callProperty.PropertyName.Name).FirstOrDefault(m => m.Parameters.Count == callProperty.ArgCount);
                            if (innerMethod == null)
                            {
                                ASClass innerClass = abc.GetClass(propertyName.Name);
                                innerMethod = innerClass.GetMethods(callProperty.PropertyName.Name).FirstOrDefault(m => m.Parameters.Count == callProperty.ArgCount);
                                }

                            string[] innerStructure = GetIncomingStructure(innerInstance, innerMethod);
                            if (innerStructure != null)
                            {
                                structure.AddRange(innerStructure);
                            }
                            else return null;
                        }
                        else
                        {
                            structure.Add(GetReadReturnTypeName(callProperty.PropertyName));
                        }
                        break;
                    }

                    case OPCode.ConstructProp:
                    {
                        var constructProp = (ConstructPropIns)next;
                        ASInstance innerInstance = abc.GetInstance(constructProp.PropertyName.Name);

                        string[] innerStructure = GetIncomingStructure(innerInstance, innerInstance.Constructor);
                        if (innerStructure != null)
                        {
                            structure.AddRange(innerStructure);
                        }
                        else return null;
                        break;
                    }

                    case OPCode.ConstructSuper:
                    {
                        var constructSuper = (ConstructSuperIns)next;
                        ASInstance superInstance = abc.GetInstance(instance.Super);
                            //ASInstance superInstance = abc.Classes.FirstOrDefault(c => c.)

                        string[] innerStructure = GetIncomingStructure(superInstance, superInstance.Constructor);
                        if (innerStructure != null)
                        {
                            structure.AddRange(innerStructure);
                        }
                        else return null;
                        break;
                    }

                    case OPCode.CallSuper:
                    {
                        var callSuper = (CallSuperIns)next;
                        ASInstance superInstance = abc.GetInstance(instance.Super.Name);

                            ASMethod superMethod = superInstance.GetMethods(callSuper.MethodName.Name).FirstOrDefault(m => m.Parameters.Count == callSuper.ArgCount);
                        string[] innerStructure = GetIncomingStructure(superInstance, superMethod);
                        if (innerStructure != null)
                        {
                            structure.AddRange(innerStructure);
                        }
                        else return null;
                        break;
                    }

                    case OPCode.CallPropVoid:
                    {
                        var callPropVoid = (CallPropVoidIns)next;
                        if (callPropVoid.ArgCount == 0)
                        {
                            structure.Add(GetReadReturnTypeName(callPropVoid.PropertyName));
                        }
                        else return null;
                        break;
                    }

                    default: return null;
                }
            }
            return structure.ToArray();
        }

        private string[] GetOutgoingStructure(ASClass @class)
        {
            ASMethod getArrayMethod = @class.Instance.GetMethod(null, "Array", 0);
            if (getArrayMethod == null)
            {
                ASClass superClass = @class.GetABC().GetClass(@class.Instance.Super.Name);
                return GetOutgoingStructure(superClass);
            }
            if (getArrayMethod.Body.Exceptions.Count > 0) return null;
            ASCode getArrayCode = getArrayMethod.Body.ParseCode();

            if (getArrayCode.JumpExits.Count > 0 ||
                getArrayCode.SwitchExits.Count > 0)
            {
                // Unable to parse data structure that relies on user input that is not present,
                // since the structure may change based on the provided input.
                return null;
            }

            ASInstruction resultPusher = null;
            for (int i = getArrayCode.Count - 1; i >= 0; i--)
            {
                ASInstruction instruction = getArrayCode[i];
                if (instruction.OP == OPCode.ReturnValue)
                {
                    resultPusher = getArrayCode[i - 1];
                    break;
                }
            }

            int argCount = -1;
            if (resultPusher.OP == OPCode.ConstructProp)
            {
                argCount = ((ConstructPropIns)resultPusher).ArgCount;
            }
            else if (resultPusher.OP == OPCode.NewArray)
            {
                argCount = ((NewArrayIns)resultPusher).ArgCount;
            }

            if (argCount > 0)
            {
                return GetOutgoingStructure(getArrayCode, resultPusher, argCount);
            }
            else if (argCount == 0 ||
                resultPusher.OP == OPCode.PushNull)
            {
                return null;
            }

            if (resultPusher.OP == OPCode.GetProperty)
            {
                var getProperty = (GetPropertyIns)resultPusher;
                return GetOutgoingStructure(Class, getProperty.PropertyName);
            }
            else if (Local.IsGetLocal(resultPusher.OP))
            {
                return GetOutgoingStructure(getArrayCode, (Local)resultPusher);
            }
            return null;
        }
        private string[] GetOutgoingStructure(ASCode code, Local getLocal)
        {
            var structure = new List<string>();
            for (int i = 0; i < code.Count; i++)
            {
                ASInstruction instruction = code[i];
                if (instruction == getLocal) break;
                if (!Local.IsGetLocal(instruction.OP)) continue;

                var local = (Local)instruction;
                if (local.Register != getLocal.Register) continue;

                for (i += 1; i < code.Count; i++)
                {
                    ASInstruction next = code[i];
                    if (next.OP != OPCode.CallPropVoid) continue;

                    var callPropVoid = (CallPropVoidIns)next;
                    if (callPropVoid.PropertyName.Name != "push") continue;

                    ASInstruction previous = code[i - 1];
                    if (previous.OP == OPCode.GetProperty)
                    {
                        ASClass classToCheck = Class;
                        var getProperty = (GetPropertyIns)previous;
                        ASMultiname propertyName = getProperty.PropertyName;

                        ASInstruction beforeGetProp = code[i - 2];
                        if (beforeGetProp.OP == OPCode.GetLex)
                        {
                            var getLex = (GetLexIns)beforeGetProp;
                            classToCheck = classToCheck.GetABC().GetClass(getLex.TypeName.Name);
                        }

                        string propertyTypeName = null;
                        if (TryGetTraitTypeName(classToCheck, propertyName, out propertyTypeName) ||
                            TryGetTraitTypeName(classToCheck.Instance, propertyName, out propertyTypeName))
                        {
                            structure.Add(propertyTypeName);
                        }
                    }
                }
            }
            return structure.ToArray();
        }
        private string[] GetOutgoingStructure(ASClass @class, ASMultiname propertyName)
        {
            ASMethod constructor = @class.Instance.Constructor;
            if (constructor.Body.Exceptions.Count > 0) return null;
            ASCode code = constructor.Body.ParseCode();

            if (code.JumpExits.Count > 0 ||
                code.SwitchExits.Count > 0)
            {
                return null;
            }

            var structure = new List<string>();
            var pushedLocals = new Dictionary<int, int>();
            for (int i = 0; i < code.Count; i++)
            {
                ASInstruction next = null;
                ASInstruction instruction = code[i];
                if (instruction.OP == OPCode.NewArray)
                {
                    var newArray = (NewArrayIns)instruction;
                    if (newArray.ArgCount > 0)
                    {
                        var structArray = new string[newArray.ArgCount];
                        for (int j = i - 1, length = newArray.ArgCount; j >= 0; j--)
                        {
                            ASInstruction previous = code[j];
                            if (Local.IsGetLocal(previous.OP) &&
                                previous.OP != OPCode.GetLocal_0)
                            {
                                var local = (Local)previous;
                                ASParameter parameter = constructor.Parameters[local.Register - 1];
                                structArray[--length] = parameter.Type.Name;
                            }
                            if (length == 0)
                            {
                                structure.AddRange(structArray);
                                break;
                            }
                        }
                    }
                }
                else if (instruction.OP == OPCode.ConstructSuper)
                {
                    var constructSuper = (ConstructSuperIns)instruction;
                    if (constructSuper.ArgCount > 0)
                    {
                        ASClass superClass = @class.GetABC().GetClass(@class.Instance.Super.Name);
                        structure.AddRange(GetOutgoingStructure(superClass, propertyName));
                    }
                }
                if (instruction.OP != OPCode.GetProperty) continue;

                var getProperty = (GetPropertyIns)instruction;
                if (getProperty.PropertyName != propertyName) continue;

                next = code[++i];
                ASClass classToCheck = @class;
                if (Local.IsGetLocal(next.OP))
                {
                    if (next.OP == OPCode.GetLocal_0)
                    {
                        classToCheck = @class;
                        continue;
                    }

                    var local = (Local)next;
                    ASParameter parameter = constructor.Parameters[local.Register - 1];
                    structure.Add(parameter.Type.Name);
                }
                else
                {
                    if (next.OP == OPCode.FindPropStrict)
                    {
                        classToCheck = null;
                    }
                    else if (next.OP == OPCode.GetLex)
                    {
                        var getLex = (GetLexIns)next;
                        classToCheck = classToCheck.GetABC().GetClass(getLex.TypeName.Name);
                    }
                    do
                    {
                        next = code[++i];
                        propertyName = null;
                        if (next.OP == OPCode.GetProperty)
                        {
                            getProperty = (GetPropertyIns)next;
                            propertyName = getProperty.PropertyName;
                        }
                        else if (next.OP == OPCode.CallProperty)
                        {
                            var callProperty = (CallPropertyIns)next;
                            propertyName = callProperty.PropertyName;
                        }
                    }
                    while (next.OP != OPCode.GetProperty && next.OP != OPCode.CallProperty);

                    string propertyTypeName = null;
                    if (TryGetTraitTypeName(classToCheck, propertyName, out propertyTypeName) ||
                        TryGetTraitTypeName(classToCheck?.Instance, propertyName, out propertyTypeName))
                    {
                        structure.Add(propertyTypeName);
                    }
                }
            }
            if (structure.Contains("Array"))
            {
                // External array... impossible to check what value types are contained in this.
                return null;
            }
            return structure.ToArray();
        }
        private string[] GetOutgoingStructure(ASCode code, ASInstruction beforeReturn, int length)
        {
            var getLocalEndIndex = -1;
            int pushingEndIndex = code.IndexOf(beforeReturn);

            var structure = new string[length];
            ASInstance instance = Class.Instance;
            var pushedLocals = new Dictionary<int, int>();
            for (int i = pushingEndIndex - 1; i >= 0; i--)
            {
                ASInstruction instruction = code[i];
                if (instruction.OP == OPCode.GetProperty)
                {
                    ASClass classToCheck = Class;
                    var getProperty = (GetPropertyIns)instruction;
                    ASMultiname propertyName = getProperty.PropertyName;

                    ASInstruction previous = code[i - 1];
                    if (previous.OP == OPCode.GetLex)
                    {
                        var getLex = (GetLexIns)previous;
                        classToCheck = classToCheck.GetABC().GetClass(getLex.TypeName.Name);
                    }

                    string propertyTypeName = null;
                    if (TryGetTraitTypeName(classToCheck, propertyName, out propertyTypeName) ||
                        TryGetTraitTypeName(classToCheck.Instance, propertyName, out propertyTypeName))
                    {
                        structure[--length] = propertyTypeName;
                    }
                }
                else if (Local.IsGetLocal(instruction.OP) &&
                    instruction.OP != OPCode.GetLocal_0)
                {
                    var local = (Local)instruction;
                    pushedLocals.Add(local.Register, --length);
                    if (getLocalEndIndex == -1)
                    {
                        getLocalEndIndex = i;
                    }
                }
                if (length == 0) break;
            }
            for (int i = (getLocalEndIndex - 1); i >= 0; i--)
            {
                ASInstruction instruction = code[i];
                if (!Local.IsSetLocal(instruction.OP)) continue;

                int structIndex = -1;
                var local = (Local)instruction;
                if (pushedLocals.TryGetValue(local.Register, out structIndex))
                {
                    ASInstruction beforeSet = code[i - 1];
                    pushedLocals.Remove(local.Register);
                    switch (beforeSet.OP)
                    {
                        case OPCode.PushInt:
                        case OPCode.PushByte:
                        case OPCode.Convert_i:
                        structure[structIndex] = "int";
                        break;

                        case OPCode.Coerce_s:
                        case OPCode.PushString:
                        structure[structIndex] = "String";
                        break;

                        case OPCode.PushTrue:
                        case OPCode.PushFalse:
                        structure[structIndex] = "Boolean";
                        break;

                        default:
                        throw new Exception($"Don't know what this value type is, tell someone about this please.\r\nOP: {beforeSet.OP}");
                    }
                }
                if (pushedLocals.Count == 0) break;
            }
            return structure;
        }

        private string GetReadReturnTypeName(ASMultiname propertyName)
        {
            switch (propertyName.Name)
            {
                case "readString":
                return "String";

                case "readBoolean":
                return "Boolean";

                case "readByte":
                return "Byte";

                case "readDouble":
                return "Double";

                default:
                {
                    if (!HGame.IsValidIdentifier(propertyName.Name, true))
                    {
                        // Most likely: readInt
                        return "int";
                    }
                    return null;
                }
            }
        }
        private string GetStrictReturnTypeName(ASMultiname propertyName)
        {
            switch (propertyName.Name)
            {
                case "int":
                case "getTimer": return "int";
            }
            return null;
        }
        private bool TryGetTraitTypeName(ASContainer container, ASMultiname propertyName, out string propertyTypeName)
        {
            if (container == null)
            {
                propertyTypeName =
                    GetStrictReturnTypeName(propertyName);
            }
            else
            {
                ASTrait propertyTrait = container.GetTraits(
                    TraitKind.Slot, TraitKind.Constant, TraitKind.Getter)
                    .Where(t => t.QName == propertyName)
                    .FirstOrDefault();

                propertyTypeName = propertyTrait?.Type.Name;
            }
            return (propertyTypeName != null);
        }
        #endregion
    }
    public class MessageReference
    {
        public bool IsStatic { get; set; }
        public bool IsAnonymous { get; set; }

        public int ClassRank { get; set; }
        public int MethodRank { get; set; }
        public int InstructionRank { get; set; }

        public int GroupCount { get; set; }

        public ASClass FromClass { get; set; }
        public ASMethod FromMethod { get; set; }
    }
}